# DEVELOPER GUIDE: gateway/base

## Quick Summary
The `base` directory provides the foundational framework for building Gateway implementations within the Solace AI Connector. It establishes abstract base classes that handle common gateway functionality including A2A (Agent-to-Agent) protocol communication, configuration management, Solace broker integration, user authentication, and task context management. Developers subclass these base classes to create gateways that bridge external platforms (web APIs, chat systems, etc.) with the AI agent ecosystem.

## Files Overview
- `__init__.py` - Package initialization file
- `app.py` - Contains `BaseGatewayApp` for application-level configuration and setup
- `component.py` - Contains `BaseGatewayComponent` for core gateway logic and A2A message processing
- `task_context.py` - Provides `TaskContextManager` for thread-safe task context storage

## Developer API Reference

### __init__.py
**Purpose:** Initializes the gateway.base package
**Import:** `from gateway.base import ...`

---

### app.py
**Purpose:** Provides the base application class that handles configuration schema merging, Solace broker setup, and component instantiation
**Import:** `from gateway.base.app import BaseGatewayApp, BaseGatewayComponent`

**Classes:**
- `BaseGatewayComponent(ComponentBase)` - Base marker class for gateway components
- `BaseGatewayApp(app_info: Dict[str, Any], **kwargs)` - Main application class for gateway implementations
  - `_get_gateway_component_class(self) -> Type[BaseGatewayComponent]` - **[Abstract]** Must return the specific gateway component class
  - `namespace: str` - Absolute topic prefix for A2A communication
  - `gateway_id: str` - Unique ID for this gateway instance
  - `artifact_service_config: Dict` - Configuration for the shared ADK Artifact Service
  - `enable_embed_resolution: bool` - Flag to enable late-stage embed resolution
  - `gateway_max_artifact_resolve_size_bytes: int` - Maximum size for artifact resolution
  - `gateway_recursive_embed_depth: int` - Maximum depth for recursive embed resolution

**Constants/Variables:**
- `BASE_GATEWAY_APP_SCHEMA: Dict[str, List[Dict[str, Any]]]` - Base configuration schema
- `SPECIFIC_APP_SCHEMA_PARAMS_ATTRIBUTE_NAME: str` - Class attribute name for subclass-specific parameters

**Usage Examples:**
```python
from typing import Type, List, Dict, Any
from gateway.base.app import BaseGatewayApp
from .component import MyGatewayComponent

class MyGatewayApp(BaseGatewayApp):
    # Define additional configuration parameters
    SPECIFIC_APP_SCHEMA_PARAMS: List[Dict[str, Any]] = [
        {
            "name": "api_key",
            "required": True,
            "type": "string",
            "description": "API key for external platform"
        }
    ]

    def _get_gateway_component_class(self) -> Type[MyGatewayComponent]:
        return MyGatewayComponent

# Usage in configuration
app_config = {
    "name": "my-gateway",
    "app_class": MyGatewayApp,
    "app_config": {
        "namespace": "myorg/prod",
        "artifact_service": {"type": "local_file"},
        "api_key": "secret-key"
    }
}
```

---

### component.py
**Purpose:** Provides the abstract base class for gateway components with core A2A protocol handling, service management, and external platform integration
**Import:** `from gateway.base.component import BaseGatewayComponent`

**Classes:**
- `BaseGatewayComponent(**kwargs: Any)` - Abstract base class for gateway components
  - **Public Methods:**
    - `get_config(self, key: str, default: Any = None) -> Any` - Retrieves configuration values, checking app_config first
    - `publish_a2a_message(self, topic: str, payload: Dict, user_properties: Optional[Dict] = None) -> None` - Publishes A2A messages to Solace broker
    - `authenticate_and_enrich_user(self, external_event_data: Any) -> Optional[Dict[str, Any]]` - Orchestrates user authentication and identity enrichment
    - `submit_a2a_task(self, target_agent_name: str, a2a_parts: List[A2APart], external_request_context: Dict[str, Any], user_identity: Any, is_streaming: bool = True, api_version: str = "v2") -> str` - Submits tasks to agents and returns task_id
    - `run(self) -> None` - Starts component operations including message processing and external listener
    - `cleanup(self) -> None` - Cleans up resources and stops all operations
  - **Abstract Methods (Must Implement):**
    - `_extract_initial_claims(self, external_event_data: Any) -> Optional[Dict[str, Any]]` - Extract user identity from platform event
    - `_start_listener(self) -> None` - Start listening to external platform
    - `_stop_listener(self) -> None` - Stop external platform listener
    - `_translate_external_input(self, external_event: Any) -> Tuple[str, List[A2APart], Dict[str, Any]]` - Convert external input to A2A format
    - `_send_update_to_external(self, external_request_context: Dict[str, Any], event_data: Union[TaskStatusUpdateEvent, TaskArtifactUpdateEvent], is_final_chunk_of_update: bool) -> None` - Send streaming updates to external platform
    - `_send_final_response_to_external(self, external_request_context: Dict[str, Any], task_data: Task) -> None` - Send final response to external platform
    - `_send_error_to_external(self, external_request_context: Dict[str, Any], error_data: JSONRPCError) -> None` - Send error to external platform
  - **Properties:**
    - `namespace: str` - A2A communication namespace
    - `gateway_id: str` - Unique gateway identifier
    - `agent_registry: AgentRegistry` - Registry of available agents
    - `core_a2a_service: CoreA2AService` - A2A protocol service
    - `shared_artifact_service: Optional[BaseArtifactService]` - Artifact storage service
    - `task_context_manager: TaskContextManager` - Task context storage
    - `identity_service: Optional[BaseIdentityService]` - User identity service

**Usage Examples:**
```python
from typing import Any, Dict, List, Optional, Tuple, Union
from gateway.base.component import BaseGatewayComponent
from ...common.types import Part as A2APart, TextPart, Task, TaskStatusUpdateEvent, TaskArtifactUpdateEvent, JSONRPCError

class MyGatewayComponent(BaseGatewayComponent):
    
    async def _extract_initial_claims(self, external_event_data: Any) -> Optional[Dict[str, Any]]:
        # Extract user identity from your platform's event
        user_id = external_event_data.get("user_id")
        if user_id:
            return {"id": user_id, "source": "my_platform"}
        return None
    
    def _start_listener(self) -> None:
        # Start your platform listener (web server, websocket, etc.)
        self.server = start_my_platform_server()
    
    def _stop_listener(self) -> None:
        # Stop your platform listener
        if hasattr(self, 'server'):
            self.server.stop()
    
    def _translate_external_input(self, external_event: Any) -> Tuple[str, List[A2APart], Dict[str, Any]]:
        # Convert platform input to A2A format
        agent_name = external_event.get("target_agent", "default-agent")
        message_text = external_event.get("message", "")
        parts = [TextPart(text=message_text)]
        context = {
            "platform_user_id": external_event.get("user_id"),
            "platform_channel": external_event.get("channel_id")
        }
        return agent_name, parts, context
    
    async def _send_update_to_external(self, external_request_context: Dict[str, Any], 
                                     event_data: Union[TaskStatusUpdateEvent, TaskArtifactUpdateEvent], 
                                     is_final_chunk_of_update: bool) -> None:
        # Send streaming update back to your platform
        channel = external_request_context.get("platform_channel")
        if isinstance(event_data, TaskStatusUpdateEvent) and event_data.status.message:
            for part in event_data.status.message.parts:
                if isinstance(part, TextPart):
                    await self.send_to_platform(channel, part.text)
    
    async def _send_final_response_to_external(self, external_request_context: Dict[str, Any], task_data: Task) -> None:
        # Send final response to your platform
        channel = external_request_context.get("platform_channel")
        if task_data.status and task_data.status.message:
            for part in task_data.status.message.parts:
                if isinstance(part, TextPart):
                    await self.send_final_to_platform(channel, part.text)
    
    async def _send_error_to_external(self, external_request_context: Dict[str, Any], error_data: JSONRPCError) -> None:
        # Send error message to your platform
        channel = external_request_context.get("platform_channel")
        await self.send_error_to_platform(channel, f"Error: {error_data.message}")

# Example of handling an incoming request
async def handle_platform_request(self, platform_event):
    # Authenticate user
    user_identity = await self.authenticate_and_enrich_user(platform_event)
    if not user_identity:
        await self.send_error_to_platform(platform_event.channel, "Authentication failed")
        return
    
    # Translate input
    agent_name, a2a_parts, context = self._translate_external_input(platform_event)
    
    # Submit task
    task_id = await self.submit_a2a_task(
        target_agent_name=agent_name,
        a2a_parts=a2a_parts,
        external_request_context=context,
        user_identity=user_identity,
        is_streaming=True
    )
    
    # Task responses will be handled automatically via the abstract methods
```

---

### task_context.py
**Purpose:** Provides thread-safe storage and retrieval of task context data
**Import:** `from gateway.base.task_context import TaskContextManager`

**Classes:**
- `TaskContextManager()` - Thread-safe manager for task context storage
  - `store_context(self, task_id: str, context_data: Dict[str, Any]) -> None` - Store context for a task
  - `get_context(self, task_id: str) -> Optional[Dict[str, Any]]` - Retrieve context for a task
  - `remove_context(self, task_id: str) -> Optional[Dict[str, Any]]` - Remove and return context for a task
  - `clear_all_contexts_for_testing(self) -> None` - Clear all contexts (testing only)

**Usage Examples:**
```python
from gateway.base.task_context import TaskContextManager

# Initialize manager
context_manager = TaskContextManager()

# Store context when submitting a task
task_context = {
    "user_id": "user123",
    "channel_id": "channel456",
    "original_message_id": "msg789"
}
context_manager.store_context("task-abc-123", task_context)

# Retrieve context when processing response
context = context_manager.get_context("task-abc-123")
if context:
    channel = context.get("channel_id")
    # Send response to the correct channel

# Clean up when task is complete
context_manager.remove_context("task-abc-123")
```

# content_hash: 46452d0e698f0f926d2e24b30ed82a6df7cde1c604ecf2a4bc9af5e0326574f9
