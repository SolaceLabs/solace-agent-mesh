# DEVELOPER GUIDE for sac

## Quick Summary
The `sac` (Solace AI Connector) directory provides the core implementation for hosting a Google ADK (Agent Development Kit) agent within the Solace AI Connector framework. It acts as a bridge, enabling ADK agents to communicate using the A2A (Agent-to-Agent) protocol over Solace messaging. This allows for the creation of distributed, collaborative agent systems where agents can delegate tasks, share information, and work together to solve complex problems.

## Files Overview
- `__init__.py` - Empty package marker file
- `app.py` - Custom SAC App class that automatically configures Solace subscriptions and broker settings for A2A communication
- `component.py` - Main SAC Component that hosts the ADK agent, manages its lifecycle, and handles all A2A protocol messaging
- `patch_adk.py` - Runtime patches for the Google ADK library to enhance or correct its behavior
- `task_execution_context.py` - State management class that encapsulates all runtime information for a single, in-flight A2A task

## Developer API Reference

### app.py
**Purpose:** Provides a custom SAC App class that simplifies the configuration of an A2A agent
**Import:** `from agent.sac.app import SamAgentApp`

**Classes:**
- `SamAgentApp(app_info: Dict[str, Any], **kwargs)` - Custom App class for SAM Agent Host with automatic subscription generation and namespace prefixing
  - `app_schema: Dict` - Class attribute defining comprehensive configuration schema for agent validation

**Constants/Variables:**
- `info: Dict[str, str]` - Metadata dictionary about the SamAgentApp class

**Usage Examples:**
```python
# SamAgentApp is typically instantiated by the SAC framework from YAML config
# Example agent-config.yaml:
app:
  class_name: agent.sac.app.SamAgentApp
  app_config:
    namespace: "my-org/production"
    agent_name: "customer-support-agent"
    model: "gemini-1.5-pro-latest"
    tools:
      - tool_type: "builtin"
        tool_name: "file_search"
    agent_card:
      description: "An agent that can answer questions about customer accounts."
    agent_card_publishing:
      interval_seconds: 60
    session_service:
      type: "memory"
```

### component.py
**Purpose:** Core component that hosts a Google ADK agent and bridges communication to A2A protocol
**Import:** `from agent.sac.component import SamAgentComponent`

**Classes:**
- `SamAgentComponent(**kwargs)` - Solace AI Connector component that hosts a Google ADK agent
  - `process_event(self, event: Event) -> None` - Main entry point for all SAC framework events
  - `handle_timer_event(self, timer_data: Dict[str, Any]) -> None` - Handles scheduled timer events
  - `handle_cache_expiry_event(self, cache_data: Dict[str, Any]) -> None` - Handles cache expiry events for peer timeouts
  - `finalize_task_success(self, a2a_context: Dict) -> None` - Async method to finalize successful tasks
  - `finalize_task_canceled(self, a2a_context: Dict) -> None` - Finalizes cancelled tasks
  - `finalize_task_error(self, exception: Exception, a2a_context: Dict) -> None` - Async method to finalize failed tasks
  - `cleanup(self) -> None` - Cleans up resources on component shutdown
  - `set_agent_specific_state(self, key: str, value: Any) -> None` - Sets agent-specific state for custom init functions
  - `get_agent_specific_state(self, key: str, default: Optional[Any] = None) -> Any` - Retrieves agent-specific state
  - `get_async_loop(self) -> Optional[asyncio.AbstractEventLoop]` - Returns the component's dedicated async event loop
  - `set_agent_system_instruction_string(self, instruction_string: str) -> None` - Sets static system prompt injection
  - `set_agent_system_instruction_callback(self, callback_function: Callable) -> None` - Sets dynamic system prompt callback
  - `get_gateway_id(self) -> str` - Returns unique identifier for this agent host instance
  - `submit_a2a_task(self, target_agent_name: str, a2a_message: A2AMessage, original_session_id: str, main_logical_task_id: str, user_id: str, user_config: Dict[str, Any], sub_task_id: str, function_call_id: Optional[str] = None) -> str` - Submits task to peer agent
  - `get_agent_context(self) -> Dict[str, Any]` - Returns agent context for middleware interactions

**Constants/Variables:**
- `info: Dict` - Metadata about the SamAgentComponent class
- `CORRELATION_DATA_PREFIX: str` - Prefix for cache keys when tracking peer requests
- `HOST_COMPONENT_VERSION: str` - Version string of the host component

**Usage Examples:**
```python
# Custom initialization function example
from agent.sac.component import SamAgentComponent

def initialize_my_agent(host_component: SamAgentComponent, config: dict):
    """Custom initialization function for the agent."""
    # Store database connection in agent state
    db_connection = create_database_connection(config.get('db_url'))
    host_component.set_agent_specific_state('db_connection', db_connection)
    
    # Set custom system instruction
    host_component.set_agent_system_instruction_string(
        "You are a specialized customer service agent with access to our database."
    )

# Tool accessing agent state
def my_custom_tool(host_component: SamAgentComponent, query: str) -> str:
    """Tool that uses stored database connection."""
    db_connection = host_component.get_agent_specific_state('db_connection')
    if db_connection:
        return db_connection.execute_query(query)
    return "Database not available"

# Submitting task to peer agent
async def delegate_to_specialist(host_component: SamAgentComponent, task_description: str):
    from common.types import A2AMessage, TextPart
    
    message = A2AMessage(
        role="user",
        parts=[TextPart(text=task_description)]
    )
    
    sub_task_id = host_component.submit_a2a_task(
        target_agent_name="specialist-agent",
        a2a_message=message,
        original_session_id="session123",
        main_logical_task_id="task456",
        user_id="user789",
        user_config={},
        sub_task_id="subtask001"
    )
    return sub_task_id
```

### patch_adk.py
**Purpose:** Contains runtime patches for the Google ADK library to enhance behavior
**Import:** `from agent.sac.patch_adk import patch_adk`

**Functions:**
- `patch_adk() -> None` - Applies all necessary patches to the ADK library

**Usage Examples:**
```python
from agent.sac.patch_adk import patch_adk

# Apply patches before using ADK
patch_adk()
```

### task_execution_context.py
**Purpose:** Encapsulates runtime state for a single, in-flight agent task
**Import:** `from agent.sac.task_execution_context import TaskExecutionContext`

**Classes:**
- `TaskExecutionContext(task_id: str, a2a_context: Dict[str, Any])` - Runtime state container for agent tasks
  - `cancel(self) -> None` - Signals that the task should be cancelled
  - `is_cancelled(self) -> bool` - Checks if cancellation event has been set
  - `append_to_streaming_buffer(self, text: str) -> None` - Appends text to streaming buffer
  - `flush_streaming_buffer(self) -> str` - Returns and clears streaming buffer content
  - `get_streaming_buffer_content(self) -> str` - Returns buffer content without clearing
  - `append_to_run_based_buffer(self, text: str) -> None` - Appends text to run-based response buffer
  - `register_peer_sub_task(self, sub_task_id: str, peer_agent_name: str) -> None` - Tracks peer sub-tasks
  - `register_parallel_call_sent(self, invocation_id: str) -> None` - Registers parallel tool calls
  - `handle_peer_timeout(self, sub_task_id: str, correlation_data: Dict, timeout_sec: int, invocation_id: str) -> bool` - Handles peer timeouts
  - `record_parallel_result(self, result: Dict, invocation_id: str) -> bool` - Records parallel call results
  - `clear_parallel_invocation_state(self, invocation_id: str) -> None` - Cleans up invocation state
  - `register_produced_artifact(self, filename: str, version: int) -> None` - Tracks created artifacts
  - `add_artifact_signal(self, signal: Dict[str, Any]) -> None` - Adds artifact return signals
  - `get_and_clear_artifact_signals(self) -> List[Dict[str, Any]]` - Retrieves and clears artifact signals
  - `set_event_loop(self, loop: asyncio.AbstractEventLoop) -> None` - Stores event loop reference
  - `get_event_loop(self) -> Optional[asyncio.AbstractEventLoop]` - Retrieves stored event loop

**Usage Examples:**
```python
from agent.sac.task_execution_context import TaskExecutionContext

# Create task context
context = TaskExecutionContext("task123", {"user_id": "user456"})

# Use streaming buffer
context.append_to_streaming_buffer("Hello ")
context.append_to_streaming_buffer("world!")
content = context.flush_streaming_buffer()  # Returns "Hello world!"

# Track parallel calls
context.register_parallel_call_sent("invocation1")
context.register_parallel_call_sent("invocation1")  # Second call for same invocation

# Record results
result1 = {"adk_function_call_id": "call1", "peer_tool_name": "tool1", "payload": {"result": "success"}}
all_complete = context.record_parallel_result(result1, "invocation1")  # Returns False

result2 = {"adk_function_call_id": "call2", "peer_tool_name": "tool2", "payload": {"result": "success"}}
all_complete = context.record_parallel_result(result2, "invocation1")  # Returns True

# Cancel task
context.cancel()
if context.is_cancelled():
    print("Task was cancelled")
```

# content_hash: 986b09a08268f49a006b6e8435b9988b92585e71967fa71febe9f466f3e715a6
