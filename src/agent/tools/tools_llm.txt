# DEVELOPER GUIDE: tools

## Quick Summary
The `tools` directory contains the complete set of built-in tools available to the agent. It follows a declarative, registry-based pattern where each tool module defines its functions and registers them with a central `tool_registry`. This allows for automatic discovery and dynamic availability of tools based on configuration and agent capabilities. The tools cover a wide range of functionalities including artifact management, audio/image processing, data analysis, web requests, and inter-agent communication.

## Files Overview
- `__init__.py` - Imports all tool modules, triggering their registration with the central registry
- `audio_tools.py` - Provides tools for text-to-speech (TTS), multi-speaker TTS, audio concatenation, and transcription
- `builtin_artifact_tools.py` - Contains core tools for creating, listing, loading, modifying, and deleting artifacts
- `builtin_data_analysis_tools.py` - Offers tools for generating charts from Plotly configurations
- `general_agent_tools.py` - Includes general-purpose utilities like file-to-markdown conversion and Mermaid diagram generation
- `image_tools.py` - Provides tools for image generation, editing, and vision-based description of images and audio
- `peer_agent_tool.py` - Defines the `PeerAgentTool` class for delegating tasks to other agents
- `registry.py` - Implements the singleton `tool_registry` for managing all tool definitions
- `test_tools.py` - Contains tools specifically for testing agent behavior, such as delays and failures
- `tool_definition.py` - Defines the `BuiltinTool` Pydantic model used for declaring tools
- `web_tools.py` - Contains tools for making HTTP requests to external web resources with content processing

## Developer API Reference

### __init__.py
**Purpose:** Ensures all built-in tool modules are imported when the tools package is loaded, triggering tool registration
**Import:** `import src.agent.tools`

**Usage Examples:**
```python
# Importing the tools package registers all built-in tools
import src.agent.tools

# Access the registry to see all registered tools
from src.agent.tools.registry import tool_registry
all_tools = tool_registry.get_all_tools()
print(f"Registered {len(all_tools)} tools.")
```

### audio_tools.py
**Purpose:** Collection of tools for audio processing including TTS, concatenation, and transcription
**Import:** `from src.agent.tools.audio_tools import select_voice, text_to_speech, multi_speaker_text_to_speech, concatenate_audio, transcribe_audio`

**Functions:**
- `select_voice(gender: Optional[str] = None, tone: Optional[str] = None, exclude_voices: Optional[List[str]] = None, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Selects a suitable voice name based on criteria like gender and tone
- `text_to_speech(text: str, output_filename: Optional[str] = None, voice_name: Optional[str] = None, gender: Optional[str] = None, tone: Optional[str] = None, language: Optional[str] = None, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Converts text to speech using Gemini TTS API and saves as MP3 artifact
- `multi_speaker_text_to_speech(conversation_text: str, output_filename: Optional[str] = None, speaker_configs: Optional[List[Dict[str, str]]] = None, language: Optional[str] = None, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Converts conversation text with speaker labels to speech using multiple voices
- `concatenate_audio(clips_to_join: List[Dict[str, Any]], output_filename: Optional[str] = None, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Combines multiple audio artifacts in specified order with optional pauses
- `transcribe_audio(audio_filename: str, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Transcribes audio using OpenAI-compatible transcription API

**Constants/Variables:**
- `ALL_AVAILABLE_VOICES: List[str]` - List of all available voice names for TTS
- `SUPPORTED_LANGUAGES: Dict[str, str]` - Mapping of language names to BCP-47 codes
- `VOICE_TONE_MAPPING: Dict[str, List[str]]` - Maps descriptive tones to voice names
- `GENDER_TO_VOICE_MAPPING: Dict[str, List[str]]` - Maps genders to voice names

**Usage Examples:**
```python
# Generate simple audio file
tts_result = await text_to_speech(
    text="Welcome to the developer guide.",
    output_filename="welcome.mp3",
    gender="female",
    tone="friendly",
    language="en-US",
    tool_context=tool_context
)

# Generate multi-speaker conversation
convo_result = await multi_speaker_text_to_speech(
    conversation_text="SpeakerA: How are you?\nSpeakerB: I am fine, thank you.",
    speaker_configs=[
        {"name": "SpeakerA", "gender": "male", "tone": "warm"},
        {"name": "SpeakerB", "gender": "female", "tone": "bright"}
    ],
    tool_context=tool_context
)
```

### builtin_artifact_tools.py
**Purpose:** Core tools for artifact management - create, read, list, update, and delete data artifacts
**Import:** `from src.agent.tools.builtin_artifact_tools import list_artifacts, load_artifact, signal_artifact_for_return, append_to_artifact, apply_embed_and_create_artifact, extract_content_from_artifact, delete_artifact`

**Functions:**
- `list_artifacts(tool_context: ToolContext = None) -> Dict[str, Any]` - Lists all available data artifact filenames and versions for current session
- `load_artifact(filename: str, version: int, load_metadata_only: bool = False, max_content_length: Optional[int] = None, tool_context: ToolContext = None) -> Dict[str, Any]` - Loads content or metadata of specific artifact version
- `signal_artifact_for_return(filename: str, version: int, tool_context: ToolContext = None) -> Dict[str, Any]` - Signals that artifact should be returned to original caller
- `append_to_artifact(filename: str, content_chunk: str, mime_type: str, tool_context: ToolContext = None) -> Dict[str, Any]` - Appends content chunk to existing artifact
- `apply_embed_and_create_artifact(output_filename: str, embed_directive: str, output_metadata: Optional[Dict[str, Any]] = None, tool_context: ToolContext = None) -> Dict[str, Any]` - Resolves embed directive and saves as new artifact
- `extract_content_from_artifact(filename: str, extraction_goal: str, version: Optional[str] = "latest", output_filename_base: Optional[str] = None, tool_context: ToolContext = None) -> Dict[str, Any]` - Uses LLM to extract/transform content from artifact
- `delete_artifact(filename: str, version: Optional[int] = None, tool_context: ToolContext = None) -> Dict[str, Any]` - Deletes specific version or all versions of artifact

**Usage Examples:**
```python
# List all artifacts
artifacts = await list_artifacts(tool_context=tool_context)
print(artifacts)

# Load specific artifact
content = await load_artifact(
    filename="data.csv",
    version=1,
    tool_context=tool_context
)

# Extract content using LLM
extracted = await extract_content_from_artifact(
    filename="report.pdf",
    extraction_goal="Extract all financial figures and create a summary table",
    tool_context=tool_context
)
```

### builtin_data_analysis_tools.py
**Purpose:** Tools for data analysis and visualization, particularly chart generation
**Import:** `from src.agent.tools.builtin_data_analysis_tools import create_chart_from_plotly_config`

**Functions:**
- `create_chart_from_plotly_config(config_content: str, config_format: Literal["json", "yaml"], output_filename: str, output_format: Optional[str] = "png", tool_context: ToolContext = None) -> Dict[str, Any]` - Generates static chart image from Plotly configuration

**Usage Examples:**
```python
# Create chart from JSON config
chart_result = await create_chart_from_plotly_config(
    config_content='{"data": [{"x": [1,2,3], "y": [4,5,6], "type": "scatter"}], "layout": {"title": "Sample Chart"}}',
    config_format="json",
    output_filename="my_chart.png",
    output_format="png",
    tool_context=tool_context
)
```

### general_agent_tools.py
**Purpose:** General-purpose utility tools for file conversion and diagram generation
**Import:** `from src.agent.tools.general_agent_tools import convert_file_to_markdown, mermaid_diagram_generator`

**Functions:**
- `convert_file_to_markdown(input_filename: str, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Converts input file artifact to Markdown using MarkItDown library
- `mermaid_diagram_generator(mermaid_syntax: str, output_filename: Optional[str] = None, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Generates PNG image from Mermaid diagram syntax

**Usage Examples:**
```python
# Convert PDF to Markdown
md_result = await convert_file_to_markdown(
    input_filename="document.pdf",
    tool_context=tool_context
)

# Generate Mermaid diagram
diagram_result = await mermaid_diagram_generator(
    mermaid_syntax="graph TD; A-->B; B-->C;",
    output_filename="flowchart.png",
    tool_context=tool_context
)
```

### image_tools.py
**Purpose:** Tools for image generation, editing, and multimodal content analysis
**Import:** `from src.agent.tools.image_tools import create_image_from_description, describe_image, describe_audio, edit_image_with_gemini`

**Functions:**
- `create_image_from_description(image_description: str, output_filename: Optional[str] = None, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Generates image from text description using configured model
- `describe_image(image_filename: str, prompt: str = "What is in this image?", tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Describes image using OpenAI-compatible vision API
- `describe_audio(audio_filename: str, prompt: str = "What is in this recording?", tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Describes audio using multimodal API
- `edit_image_with_gemini(image_filename: str, edit_prompt: str, output_filename: Optional[str] = None, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Edits existing image using Gemini 2.0 Flash Preview

**Usage Examples:**
```python
# Generate image from description
image_result = await create_image_from_description(
    image_description="A sunset over mountains with a lake in the foreground",
    output_filename="sunset.png",
    tool_context=tool_context
)

# Describe existing image
description = await describe_image(
    image_filename="photo.jpg",
    prompt="Describe the objects and people in this image",
    tool_context=tool_context
)
```

### peer_agent_tool.py
**Purpose:** Defines PeerAgentTool class for delegating tasks to other agents
**Import:** `from src.agent.tools.peer_agent_tool import PeerAgentTool`

**Classes:**
- `PeerAgentTool(target_agent_name: str, host_component)` - ADK Tool for delegating tasks to peer agents
  - `run_async(args: Dict[str, Any], tool_context: ToolContext) -> Any` - Handles task delegation to peer agent
  - `_get_declaration() -> Optional[adk_types.FunctionDeclaration]` - Dynamically generates function declaration

**Usage Examples:**
```python
# Create peer agent tool
peer_tool = PeerAgentTool(
    target_agent_name="data_analyst",
    host_component=host_component
)

# The tool is typically used by the LLM, not directly by developers
```

### registry.py
**Purpose:** Singleton registry for discovering and managing all BuiltinTool definitions
**Import:** `from src.agent.tools.registry import tool_registry`

**Classes:**
- `_ToolRegistry()` - Singleton registry for tool management
  - `register(tool: BuiltinTool)` - Registers a tool in the registry
  - `get_tool_by_name(name: str) -> Optional[BuiltinTool]` - Returns tool by name
  - `get_tools_by_category(category_name: str) -> List[BuiltinTool]` - Returns tools by category
  - `get_all_tools() -> List[BuiltinTool]` - Returns all registered tools
  - `clear()` - Clears all registered tools (testing only)

**Constants/Variables:**
- `tool_registry: _ToolRegistry` - The singleton registry instance

**Usage Examples:**
```python
from src.agent.tools.registry import tool_registry
from src.agent.tools.tool_definition import BuiltinTool

# Get all tools
all_tools = tool_registry.get_all_tools()

# Get specific tool
artifact_tool = tool_registry.get_tool_by_name("list_artifacts")

# Get tools by category
audio_tools = tool_registry.get_tools_by_category("audio")
```

### test_tools.py
**Purpose:** Tools specifically for testing agent behavior and error handling
**Import:** `from src.agent.tools.test_tools import time_delay, always_fail_tool, dangling_tool_call_test_tool`

**Functions:**
- `time_delay(seconds: float, tool_context: ToolContext = None, tool_config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]` - Pauses execution for specified seconds
- `always_fail_tool() -> dict` - Always raises exception for testing error handling
- `dangling_tool_call_test_tool() -> None` - Returns None to create dangling tool call for testing

**Usage Examples:**
```python
# Add delay for testing
delay_result = await time_delay(
    seconds=2.5,
    tool_context=tool_context
)

# These tools are primarily for internal testing
```

### tool_definition.py
**Purpose:** Defines the Pydantic model for self-contained BuiltinTool definitions
**Import:** `from src.agent.tools.tool_definition import BuiltinTool`

**Classes:**
- `BuiltinTool(BaseModel)` - Pydantic model for tool definitions
  - `name: str` - Function name the LLM will call
  - `implementation: Callable` - Async Python function implementing the tool
  - `description: str` - High-level description for LLM understanding
  - `parameters: adk_types.Schema` - OpenAPI-like

# content_hash: da5077941d1f5801bc093583679cfc9c959fa8c70cf3e7ba8ab3ad6d7f2b8a3a
