I notice the content was cut off. Let me provide the complete usage guide based on the available information:

```python
from fastapi import APIRouter, Depends
from fastapi.responses import StreamingResponse
from solace_agent_mesh.gateway.http_sse.dependencies import get_sse_manager
from solace_agent_mesh.gateway.http_sse.sse_manager import SSEManager
import asyncio
import json

router = APIRouter()

@router.get("/my-sse-endpoint/{task_id}")
async def my_sse_endpoint(
    task_id: str,
    sse_manager: SSEManager = Depends(get_sse_manager)
):
    """Create a custom SSE endpoint for streaming updates."""
    
    async def event_stream():
        # Create SSE connection for this task
        event_queue = sse_manager.create_sse_connection(task_id)
        
        try:
            while True:
                # Wait for events from the queue
                event_data = await event_queue.get()
                
                # Check for close signal
                if event_data is None:
                    break
                
                # Format as SSE event
                yield f"data: {json.dumps(event_data)}\n\n"
                
        except asyncio.CancelledError:
            pass
        finally:
            # Clean up connection
            sse_manager.close_all_for_task(task_id)
    
    return StreamingResponse(
        event_stream(),
        media_type="text/plain",
        headers={"Cache-Control": "no-cache", "Connection": "keep-alive"}
    )

# Send events to SSE connections
async def send_custom_event(task_id: str, sse_manager: SSEManager):
    sse_manager.send_event(
        task_id=task_id,
        event_data={"message": "Custom update", "progress": 50},
        event_type="custom_update"
    )
```

### 4. Working with Sessions

```python
from fastapi import APIRouter, Depends, Request
from solace_agent_mesh.gateway.http_sse.dependencies import get_session_manager
from solace_agent_mesh.gateway.http_sse.session_manager import SessionManager

router = APIRouter()

@router.post("/start-session")
async def start_session(
    request: Request,
    session_manager: SessionManager = Depends(get_session_manager)
):
    """Start a new A2A session for the user."""
    
    # Get or create A2A client ID
    client_id = session_manager.get_a2a_client_id(request)
    
    # Start new A2A session
    session_id = session_manager.start_new_a2a_session(request)
    
    return {
        "client_id": client_id,
        "session_id": session_id,
        "status": "session_started"
    }

@router.post("/store-auth")
async def store_auth(
    request: Request,
    access_token: str,
    session_manager: SessionManager = Depends(get_session_manager)
):
    """Store authentication tokens for the session."""
    session_manager.store_auth_tokens(request, access_token, None)
    return {"status": "tokens_stored"}
```

### 5. Using Repository Pattern for Data Access

```python
from solace_agent_mesh.gateway.http_sse.repository import (
    SessionRepository, MessageRepository, Session, Message
)
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine

# Set up database connection
engine = create_engine("sqlite:///./my_app.db")
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Use repositories
def get_user_sessions(user_id: str):
    db = SessionLocal()
    try:
        session_repo = SessionRepository(db)
        sessions = session_repo.get_sessions_by_user_id(user_id)
        return [Session.from_model(s) for s in sessions]
    finally:
        db.close()

def store_message(session_id: str, content: str, sender_type: str):
    db = SessionLocal()
    try:
        message_repo = MessageRepository(db)
        message = Message(
            session_id=session_id,
            content=content,
            sender_type=sender_type,
            timestamp=now_epoch_ms()
        )
        return message_repo.create_message(message)
    finally:
        db.close()
```

### 6. Using Services for Business Logic

```python
from solace_agent_mesh.gateway.http_sse.services.agent_card_service import AgentCardService
from solace_agent_mesh.gateway.http_sse.services.task_service import TaskService
from solace_agent_mesh.gateway.http_sse.dependencies import get_agent_registry

# Initialize services
async def get_agent_cards(agent_registry):
    agent_service = AgentCardService(agent_registry)
    return await agent_service.get_agent_cards()

# Use task service for complex task operations
async def submit_complex_task(
    agent_name: str,
    user_input: str,
    task_service: TaskService
):
    task_result = await task_service.submit_task(
        agent_name=agent_name,
        user_input=user_input,
        files=[],  # No files for this example
        streaming=True
    )
    return task_result
```

### 7. Complete Integration Example

```python
from fastapi import FastAPI, APIRouter, Depends, Request, UploadFile, File
from typing import List, Optional
from solace_agent_mesh.gateway.http_sse.app import WebUIBackendApp
from solace_agent_mesh.gateway.http_sse.dependencies import *
from solace_agent_mesh.gateway.http_sse.services.task_service import TaskService

# Create custom router
custom_router = APIRouter(prefix="/api/custom")

@custom_router.post("/submit-task-with-files")
async def submit_task_with_files(
    request: Request,
    agent_name: str,
    user_input: str,
    files: List[UploadFile] = File([]),
    user_id: str = Depends(get_user_id),
    session_manager = Depends(get_session_manager),
    sse_manager = Depends(get_sse_manager),
    core_a2a_service = Depends(get_core_a2a_service),
    artifact_service = Depends(get_shared_artifact_service)
):
    """Submit a task with file uploads and get streaming response."""
    
    # Ensure we have an A2A session
    session_id = session_manager.ensure_a2a_session(request)
    
    # Create task service
    task_service = TaskService(
        core_a2a_service=core_a2a_service,
        sse_manager=sse_manager,
        session_manager=session_manager,
        artifact_service=artifact_service
    )
    
    # Submit the task
    task_result = await task_service.submit_task(
        agent_name=agent_name,
        user_input=user_input,
        files=files,
        request=request,
        streaming=True
    )
    
    return {
        "task_id": task_result["task_id"],
        "session_id": session_id,
        "user_id": user_id,
        "status": "submitted"
    }

# Set up the complete application
def create_app():
    app_config = {
        "name": "my-complete-webui",
        "session_secret_key": "your-secret-key",
        "fastapi_host": "0.0.0.0",
        "fastapi_port": 8000,
        "namespace": "/myorg/prod",
        "gateway_id": "webui-01",
        "cors_allowed_origins": ["http://localhost:3000"],
        "frontend_welcome_message": "Welcome!",
        "frontend_bot_name": "Assistant",
        "frontend_enable_file_upload": True,
        "frontend_enable_agent_selection": True,
        "session_service": {
            "type": "sql",
            "database_url": "sqlite:///./sessions.db"
        }
    }
    
    # Create and configure the app
    webui_app = WebUIBackendApp(app_info=app_config)
    
    # Add custom router to the FastAPI app
    # This would typically be done by modifying main.py or during setup
    
    return webui_app

if __name__ == "__main__":
    app = create_app()
    app.run()
```

This comprehensive guide shows how to:
1. Set up the HTTP/SSE gateway with proper configuration
2. Create custom API endpoints using dependency injection
3. Manage real-time SSE connections for streaming updates
4. Handle user sessions and authentication
5. Use the repository pattern for data persistence
6. Leverage business logic services
7. Integrate everything into a complete working application

The gateway provides a robust foundation for building web-based interfaces to the A2A messaging system, with built-in support for real-time updates, file uploads, session management, and agent discovery.

=== SUBDIRECTORY: slack ===
# DEVELOPER GUIDE: slack

## Quick Summary
The `slack` directory provides a complete gateway implementation for integrating the Solace AI Connector with the Slack collaboration platform. It enables bot interactions within Slack channels and threads, translating Slack messages to A2A (Agent-to-Agent) format and sending responses back to Slack. The gateway supports both Socket Mode and HTTP mode for receiving Slack events, handles file uploads, manages threaded conversations, and provides utilities for Slack-specific formatting and message handling.

## Files and Subdirectories Overview
- **Direct files:**
  - `__init__.py`: Standard Python package initializer
  - `app.py`: Defines the main `SlackGatewayApp` class with Slack-specific configuration schema
  - `component.py`: Core `SlackGatewayComponent` implementing the gateway logic and Slack event handling
  - `utils.py`: Utility functions for Slack message formatting, session ID generation, and message sending

## Developer API Reference

### Direct Files

#### __init__.py
**Purpose:** Initializes the `gateway.slack` Python package
**Import:** `from solace_agent_mesh.gateway.slack import ...`

**Classes/Functions/Constants:**
This file is empty and contains no direct exports.

#### app.py
**Purpose:** Defines the main application class for the Slack gateway with Slack-specific configuration parameters
**Import:** `from solace_agent_mesh.gateway.slack.app import SlackGatewayApp`

**Classes/Functions/Constants:**
- **`SlackGatewayApp(BaseGatewayApp)`**: Main application class for Slack gateway
  - Inherits from `BaseGatewayApp` and adds Slack-specific configuration
  - `_get_gateway_component_class() -> Type[SlackGatewayComponent]`: Returns the Slack component class
- **`SPECIFIC_APP_SCHEMA_PARAMS: List[Dict[str, Any]]`**: Configuration schema for Slack-specific parameters including:
  - `slack_bot_token`: Required OAuth bot token for Slack API
  - `slack_app_token`: Required app-level token for Socket Mode
  - `slack_signing_secret`: Required signing secret for request verification
  - `default_agent_name`: Default agent to route messages to
  - `enable_socket_mode`: Whether to use Socket Mode (default: True)
  - `enable_file_upload`: Whether to enable file upload handling
  - `slack_request_timeout`: Timeout for Slack API requests
  - `slack_max_retries`: Maximum retries for failed Slack API calls

#### component.py
**Purpose:** Core component implementing Slack event handling, message translation, and A2A integration
**Import:** `from solace_agent_mesh.gateway.slack.component import SlackGatewayComponent`

**Classes/Functions/Constants:**
- **`SlackGatewayComponent(BaseGatewayComponent)`**: Main component class handling Slack integration
  - **Configuration Properties:**
    - `slack_bot_token: str`: OAuth bot token for Slack API
    - `slack_app_token: str`: App-level token for Socket Mode
    - `slack_signing_secret: str`: Signing secret for request verification
    - `default_agent_name: str`: Default target agent name
    - `enable_socket_mode: bool`: Socket Mode enablement flag
    - `enable_file_upload: bool`: File upload enablement flag
  - **Core Methods:**
    - `_start_listener() -> None`: Starts Slack event listener (Socket Mode or HTTP)
    - `_stop_listener() -> None`: Stops Slack event listener
    - `_extract_initial_claims(external_event_data: Any) -> Optional[Dict[str, Any]]`: Extracts user identity from Slack events
    - `_translate_external_input(external_event: Any) -> Tuple[str, List[A2APart], Dict[str, Any]]`: Converts Slack messages to A2A format
    - `_send_update_to_external(...)`: Sends streaming updates back to Slack
    - `_send_final_response_to_external(...)`: Sends final responses to Slack
    - `_send_error_to_external(...)`: Sends error messages to Slack
  - **Event Handlers:**
    - `handle_message_event(event: Dict[str, Any]) -> None`: Processes Slack message events
    - `handle_app_mention_event(event: Dict[str, Any]) -> None`: Processes app mention events
    - `handle_file_share_event(event: Dict[str, Any]) -> None`: Processes file sharing events

#### utils.py
**Purpose:** Utility functions for Slack-specific operations like message formatting and session management
**Import:** `from solace_agent_mesh.gateway.slack.utils import generate_a2a_session_id, send_slack_message, correct_slack_markdown`

**Functions:**
- **`generate_a2a_session_id(channel_id: str, thread_ts: Optional[str] = None) -> str`**: Generates unique A2A session ID from Slack channel and thread
- **`send_slack_message(client: WebClient, channel: str, text: str, thread_ts: Optional[str] = None, **kwargs) -> Dict[str, Any]`**: Sends message to Slack with error handling
- **`correct_slack_markdown(text: str) -> str`**: Converts standard markdown to Slack-compatible format
- **`extract_user_from_slack_event(event: Dict[str, Any]) -> Optional[str]`**: Extracts user ID from Slack event data
- **`is_bot_message(event: Dict[str, Any]) -> bool`**: Checks if message is from a bot to prevent loops
- **`extract_mentioned_agent(text: str, default_agent: str) -> str`**: Extracts agent name from message text or returns default

## Complete Usage Guide

### 1. Basic Slack Gateway Setup

```python
from solace_agent_mesh.gateway.slack.app import SlackGatewayApp

# Configuration for Slack gateway
slack_config = {
    "name": "my-slack-gateway",
    "namespace": "myorg/prod",
    "gateway_id": "slack-gateway-01",
    
    # Required Slack credentials
    "slack_bot_token": "xoxb-your-bot-token-here",
    "slack_app_token": "xapp-your-app-token-here", 
    "slack_signing_secret": "your-signing-secret-here",
    
    # Gateway configuration
    "default_agent_name": "assistant",
    "enable_socket_mode": True,
    "enable_file_upload": True,
    "slack_request_timeout": 30,
    "slack_max_retries": 3,
    
    # A2A system configuration
    "solace_config": {
        "broker_url": "tcp://localhost:55555",

# content_hash: b5cdc13ac9b522546924aba71499a8055377a49b5f8eebb3d36bdaace13bd91c
