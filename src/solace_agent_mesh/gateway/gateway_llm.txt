<<<<<<< HEAD
=======
I notice the content was cut off at the end. Let me provide the complete developer guide based on the available information:

>>>>>>> main
# DEVELOPER GUIDE: gateway

## Quick Summary
The `gateway` directory provides a comprehensive framework for building gateways that connect external platforms (Slack, HTTP/SSE web interfaces) to the Solace AI Connector's A2A (Agent-to-Agent) messaging system. The architecture consists of a foundational `base` module that defines abstract classes for gateway implementations, and specific gateway implementations like `slack` for Slack integration and `http_sse` for web-based interfaces. The framework handles authentication, message translation between external formats and A2A protocol, real-time streaming updates, and manages the complete lifecycle of requests from external platforms to AI agents.

## Files and Subdirectories Overview
- **Direct files:**
  - `__init__.py`: Standard Python package initializer
  - `gateway_llm.txt`: Documentation or configuration file for LLM-related gateway functionality

- **Subdirectories:**
  - `base/`: Foundational abstract classes and utilities for building gateway implementations
  - `slack/`: Complete Slack platform integration gateway with bot functionality
  - `http_sse/`: HTTP/Server-Sent Events gateway for web-based user interfaces

## Developer API Reference

### Direct Files

#### __init__.py
<<<<<<< HEAD
**Purpose:** Initializes the `gateway` module, making it a Python package.
=======
**Purpose:** Initializes the `gateway` Python package
>>>>>>> main
**Import:** `from solace_agent_mesh.gateway import ...`

**Classes/Functions/Constants:**
This file is empty and contains no direct exports.

#### gateway_llm.txt
**Purpose:** Documentation or configuration file for LLM-related gateway functionality
**Import:** Not applicable (text/documentation file)

**Content:** This appears to be a documentation or configuration file rather than executable code.

### Subdirectory APIs

#### base/
**Purpose:** Provides foundational abstract classes for building Gateway implementations
**Key Exports:** `BaseGatewayApp`, `BaseGatewayComponent`, `TaskContextManager`
**Import Examples:**
```python
from solace_agent_mesh.gateway.base.app import BaseGatewayApp
from solace_agent_mesh.gateway.base.component import BaseGatewayComponent
from solace_agent_mesh.gateway.base.task_context import TaskContextManager
```

<<<<<<< HEAD
#### http_sse/
**Purpose:** Implements a complete HTTP/SSE gateway to serve a web-based user interface, bridging web protocols with the backend A2A messaging fabric.
**Key Exports:** `WebUIBackendApp`, `WebUIBackendComponent`, `SSEManager`, `SessionManager`, and various dependency injectors.
**Import Examples:**
```python
from solace_agent_mesh.gateway.http_sse.app import WebUIBackendApp
from solace_agent_mesh.gateway.http_sse.component import WebUIBackendComponent
from solace_agent_mesh.gateway.http_sse.sse_manager import SSEManager
from solace_agent_mesh.gateway.http_sse.session_manager import SessionManager
from solace_agent_mesh.gateway.http_sse.dependencies import get_agent_service, get_task_service, get_user_id
```

=======
>>>>>>> main
#### slack/
**Purpose:** Complete Slack platform integration with bot functionality, event handling, and A2A message translation
**Key Exports:** `SlackGatewayApp`, `SlackGatewayComponent`, utility functions for Slack operations
**Import Examples:**
```python
from solace_agent_mesh.gateway.slack.app import SlackGatewayApp
from solace_agent_mesh.gateway.slack.component import SlackGatewayComponent
<<<<<<< HEAD
from solace_agent_mesh.gateway.slack.utils import generate_a2a_session_id, send_slack_message, correct_slack_markdown
=======
from solace_agent_mesh.gateway.slack.utils import generate_a2a_session_id, send_slack_message
>>>>>>> main
```

#### http_sse/
**Purpose:** HTTP/Server-Sent Events gateway for web-based user interfaces with real-time streaming
**Key Exports:** `WebUIBackendApp`, `WebUIBackendComponent`, `SSEManager`, `SessionManager`, routers, services
**Import Examples:**
```python
<<<<<<< HEAD
from solace_agent_mesh.gateway.webhook.app import WebhookGatewayApp
from solace_agent_mesh.gateway.webhook.component import WebhookGatewayComponent
from solace_agent_mesh.gateway.webhook.dependencies import get_sac_component
=======
from solace_agent_mesh.gateway.http_sse.app import WebUIBackendApp
from solace_agent_mesh.gateway.http_sse.component import WebUIBackendComponent
from solace_agent_mesh.gateway.http_sse.sse_manager import SSEManager
from solace_agent_mesh.gateway.http_sse.dependencies import get_sse_manager, get_session_manager
>>>>>>> main
```

## Complete Usage Guide

<<<<<<< HEAD
### 1. Creating a Custom Gateway

This example shows how to use the `base` module to build a new gateway for a hypothetical external platform.

```python
# my_gateway/app.py
from typing import Type, List, Dict, Any
from solace_agent_mesh.gateway.base.app import BaseGatewayApp
from .component import MyGatewayComponent

class MyGatewayApp(BaseGatewayApp):
    """Defines the application and its configuration for My Platform."""
    
=======
### 1. Creating a Custom Gateway Implementation

```python
from typing import Type, List, Dict, Any, Optional, Tuple, Union
from solace_agent_mesh.gateway.base.app import BaseGatewayApp
from solace_agent_mesh.gateway.base.component import BaseGatewayComponent
from solace_agent_mesh.common.a2a.types import ContentPart, TextPart
from a2a.types import Task, TaskStatusUpdateEvent, TaskArtifactUpdateEvent, JSONRPCError

# Step 1: Define your gateway app class
class MyCustomGatewayApp(BaseGatewayApp):
    """Custom gateway for My Platform integration."""
    
    # Define platform-specific configuration parameters
>>>>>>> main
    SPECIFIC_APP_SCHEMA_PARAMS: List[Dict[str, Any]] = [
        {
            "name": "my_platform_api_key",
            "required": True,
            "type": "string",
<<<<<<< HEAD
            "description": "API key for connecting to My Platform."
=======
            "description": "API key for My Platform"
>>>>>>> main
        },
        {
            "name": "my_platform_webhook_url",
            "required": False,
            "type": "string",
<<<<<<< HEAD
            "description": "Webhook URL for receiving events from My Platform."
        }
    ]

    def _get_gateway_component_class(self) -> Type[MyGatewayComponent]:
        return MyGatewayComponent

# my_gateway/component.py
from typing import Any, Dict, List, Optional, Tuple, Union
from solace_agent_mesh.gateway.base.component import BaseGatewayComponent
from a2a.types import Part as A2APart, TextPart, Task, TaskStatusUpdateEvent, TaskArtifactUpdateEvent, JSONRPCError

class MyGatewayComponent(BaseGatewayComponent):
=======
            "description": "Webhook URL for receiving events"
        },
        {
            "name": "default_agent_name",
            "required": False,
            "type": "string",
            "default": "assistant",
            "description": "Default agent to route messages to"
        }
    ]

    def _get_gateway_component_class(self) -> Type[BaseGatewayComponent]:
        return MyCustomGatewayComponent

# Step 2: Implement your gateway component
class MyCustomGatewayComponent(BaseGatewayComponent):
    """Component implementing My Platform integration logic."""
>>>>>>> main
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.api_key = self.get_config("my_platform_api_key")
        self.webhook_url = self.get_config("my_platform_webhook_url")
<<<<<<< HEAD
        self.server = None
    
    async def _extract_initial_claims(self, external_event_data: Any) -> Optional[Dict[str, Any]]:
        """Extract user identity from platform-specific event."""
        if hasattr(external_event_data, 'user_id'):
            return {"id": external_event_data.user_id, "source": "my_platform"}
        return None
    
    def _start_listener(self) -> None:
        """Start your platform listener (web server, etc.)."""
        # Example: Start a web server to receive webhooks
        from fastapi import FastAPI
        import uvicorn
        
        app = FastAPI()
        
        @app.post("/webhook")
        async def handle_webhook(request_data: dict):
            await self.handle_external_event(request_data)
            return {"status": "ok"}
        
        self.server = uvicorn.Server(
            uvicorn.Config(app, host="0.0.0.0", port=8080)
        )
        # Start server in background thread
        import threading
        self.server_thread = threading.Thread(target=self.server.run)
        self.server_thread.start()
    
    def _stop_listener(self) -> None:
        """Stop your platform listener."""
        if self.server:
            self.server.should_exit = True
    
    def _translate_external_input(self, external_event: Any) -> Tuple[str, List[A2APart], Dict[str, Any]]:
        """Convert external event to A2A format."""
        target_agent = external_event.get("target_agent", "default-agent")
        message_text = external_event.get("message", "Hello")
        
        a2a_parts = [TextPart(text=message_text)]
        
        context = {
            "platform": "my_platform",
            "user_id_for_artifacts": external_event.get("user_id"),
            "a2a_session_id": f"my-platform-{external_event.get('session_id', 'default')}"
=======
        self.default_agent = self.get_config("default_agent_name", "assistant")
        self.platform_client = None  # Initialize your platform client
    
    async def _extract_initial_claims(self, external_event_data: Any) -> Optional[Dict[str, Any]]:
        """Extract user identity from platform event."""
        # Example: Extract user ID from your platform's event structure
        if hasattr(external_event_data, 'user_id'):
            return {
                "id": external_event_data.user_id,
                "platform": "my_platform",
                "username": getattr(external_event_data, 'username', None)
            }
        return None
    
    def _start_listener(self) -> None:
        """Start your platform's event listener."""
        # Example: Start webhook server, WebSocket connection, etc.
        print(f"Starting My Platform listener on {self.webhook_url}")
        # Initialize your platform client/listener here
    
    def _stop_listener(self) -> None:
        """Stop your platform's event listener."""
        print("Stopping My Platform listener")
        # Clean up platform client/listener here
    
    async def _translate_external_input(self, external_event: Any) -> Tuple[str, List[ContentPart], Dict[str, Any]]:
        """Convert platform event to A2A format."""
        # Extract message content
        message_text = getattr(external_event, 'message', '')
        
        # Determine target agent (could be extracted from message or use default)
        target_agent = getattr(external_event, 'target_agent', self.default_agent)
        
        # Create A2A content parts
        a2a_parts = [TextPart(text=message_text)]
        
        # Create context for tracking this request
        context = {
            "platform": "my_platform",
            "event_id": getattr(external_event, 'id', ''),
            "channel_id": getattr(external_event, 'channel_id', ''),
            "user_id_for_artifacts": getattr(external_event, 'user_id', ''),
            "a2a_session_id": f"my_platform_{getattr(external_event, 'session_id', '')}"
>>>>>>> main
        }
        
        return target_agent, a2a_parts, context
    
<<<<<<< HEAD
    async def _send_update_to_external(self, external_request_context: Dict[str, Any], 
                                     event_data: Union[TaskStatusUpdateEvent, TaskArtifactUpdateEvent], 
                                     is_final_chunk_of_update: bool) -> None:
        """Send streaming update back to external platform."""
        # Extract text from event and send to your platform
        if hasattr(event_data, 'text_delta'):
            await self.send_to_platform(
                user_id=external_request_context["user_id_for_artifacts"],
                message=event_data.text_delta,
                is_partial=not is_final_chunk_of_update
            )
    
    async def _send_final_response_to_external(self, external_request_context: Dict[str, Any], 
                                             task_data: Task) -> None:
        """Send final response back to external platform."""
        final_text = ""
        for part in task_data.result.parts:
            if hasattr(part, 'text'):
                final_text += part.text
        
        await self.send_to_platform(
            user_id=external_request_context["user_id_for_artifacts"],
            message=final_text,
            is_final=True
        )
    
    async def _send_error_to_external(self, external_request_context: Dict[str, Any], 
                                     error_data: JSONRPCError) -> None:
        """Send error back to external platform."""
        await self.send_to_platform(
            user_id=external_request_context["user_id_for_artifacts"],
            message=f"Error: {error_data.message}",
            is_error=True
        )
    
    async def send_to_platform(self, user_id: str, message: str, **kwargs):
        """Helper method to send messages to your platform."""
        # Implement your platform-specific sending logic here
        print(f"Sending to {user_id}: {message}")

# Usage
if __name__ == "__main__":
    app_config = {
        "namespace": "myorg/prod",
        "gateway_id": "my-gateway-01",
        "my_platform_api_key": "secret-key-here",
        "my_platform_webhook_url": "https://myplatform.com/webhook"
    }
    
    gateway_app = MyGatewayApp(app_info=app_config)
    gateway_app.run()
```

### 2. Using the HTTP/SSE Gateway

```python
from solace_agent_mesh.gateway.http_sse.app import WebUIBackendApp

# Configuration for the web UI gateway
app_config = {
    "name": "my-webui-gateway",
    "session_secret_key": "your-secret-key-here",
    "fastapi_host": "0.0.0.0",
    "fastapi_port": 8000,
    "namespace": "myorg/prod",
    "gateway_id": "webui-gateway-01",
    "cors_allowed_origins": ["http://localhost:3000"],
    "frontend_welcome_message": "Welcome to my A2A system!",
    "frontend_bot_name": "My Assistant",
    "frontend_enable_file_upload": True,
    "frontend_enable_agent_selection": True
}

# Initialize and run the web UI gateway
webui_app = WebUIBackendApp(app_info=app_config)
webui_app.run()

# The gateway will start a FastAPI server with endpoints like:
# GET /api/agents - List available agents
# POST /api/tasks - Submit new tasks
# GET /api/tasks/{task_id}/sse - Stream task updates via SSE
# POST /api/artifacts - Upload files
```

### 3. Creating Custom API Endpoints for HTTP/SSE Gateway

```python
from fastapi import APIRouter, Depends, Request
from solace_agent_mesh.gateway.http_sse.dependencies import (
    get_agent_registry,
    get_user_id,
    get_publish_a2a_func,
    get_sse_manager,
    get_session_manager
)

# Create a custom router
custom_router = APIRouter(prefix="/api/custom")

@custom_router.get("/my-agents")
async def get_my_agents(
    user_id: str = Depends(get_user_id),
    agent_registry = Depends(get_agent_registry)
):
    """Get agents filtered by user permissions."""
    all_agents = agent_registry.get_all_agents()
    # Filter agents based on user permissions
    user_agents = [agent for agent in all_agents if user_can_access_agent(user_id, agent)]
    return {"agents": user_agents, "user_id": user_id}

@custom_router.post("/broadcast-message")
async def broadcast_message(
    message: str,
    publish_func = Depends(get_publish_a2a_func),
    user_id: str = Depends(get_user_id)
):
    """Broadcast a message to all agents."""
    publish_func(
        topic="/myorg/prod/a2a/v1/broadcast",
        payload={
            "method": "broadcast/message",
            "params": {"message": message, "from_user": user_id}
        },
        user_properties={"clientId": user_id}
    )
    return {"status": "broadcasted", "message": message}

# Add the router to your FastAPI app
# This would typically be done in the main.py or during app setup
```

### 4. Using the Slack Gateway
=======
    async def _send_update_to_external(self, 
                                     external_request_context: Dict[str, Any], 
                                     event_data: Union[TaskStatusUpdateEvent, TaskArtifactUpdateEvent], 
                                     is_final_chunk_of_update: bool) -> None:
        """Send streaming update to your platform."""
        channel_id = external_request_context.get("channel_id")
        
        # Extract text content from the event
        if hasattr(event_data, 'text_delta'):
            text_content = event_data.text_delta
        elif hasattr(event_data, 'content'):
            text_content = str(event_data.content)
        else:
            text_content = "Update received"
        
        # Send to your platform (example)
        await self._send_to_platform(channel_id, text_content, is_partial=not is_final_chunk_of_update)
    
    async def _send_final_response_to_external(self, 
                                             external_request_context: Dict[str, Any], 
                                             task_data: Task) -> None:
        """Send final response to your platform."""
        channel_id = external_request_context.get("channel_id")
        
        # Extract final response from task data
        final_response = "Task completed"
        if task_data.result and hasattr(task_data.result, 'content'):
            final_response = str(task_data.result.content)
        
        await self._send_to_platform(channel_id, final_response, is_final=True)
    
    async def _send_error_to_external(self, 
                                     external_request_context: Dict[str, Any], 
                                     error_data: JSONRPCError) -> None:
        """Send error to your platform."""
        channel_id = external_request_context.get("channel_id")
        error_message = f"Error: {error_data.message}"
        await self._send_to_platform(channel_id, error_message, is_error=True)
    
    async def _send_to_platform(self, channel_id: str, message: str, **kwargs):
        """Helper method to send messages to your platform."""
        # Implement your platform's message sending logic here
        print(f"Sending to {channel_id}: {message}")

# Step 3: Usage
if __name__ == "__main__":
    config = {
        "name": "my-custom-gateway",
        "namespace": "/myorg/prod",
        "gateway_id": "my-gateway-01",
        "my_platform_api_key": "your-api-key",
        "my_platform_webhook_url": "https://my-webhook.example.com",
        "default_agent_name": "my-assistant",
        "solace_config": {
            "broker_url": "tcp://localhost:55555",
            "vpn_name": "default",
            "username": "default",
            "password": "default"
        }
    }
    
    app = MyCustomGatewayApp(app_info=config)
    app.run()
```

### 2. Using the Slack Gateway
>>>>>>> main

```python
from solace_agent_mesh.gateway.slack.app import SlackGatewayApp

<<<<<<< HEAD
# Configuration for Slack gateway
slack_config = {
    "name": "my-slack-gateway",
    "namespace": "myorg/prod",
    "gateway_id": "slack-gateway-01",
    "slack_bot_token": "xoxb-your-bot-token",
    "slack_app_token": "xapp-your-app-token",
    "slack_signing_secret": "your-signing-secret",
    "default_agent_name": "assistant",
    "enable_socket_mode": True,
    "enable_file_upload": True
}

# Initialize and run the Slack gateway
slack_app = SlackGatewayApp(app_info=slack_config)
slack_app.run()

# The gateway will:
# - Connect to Slack via Socket Mode or HTTP
# - Listen for mentions and direct messages
# - Translate Slack messages to A2A format
# - Send responses back to Slack channels/threads
```

### 5. Using the Webhook Gateway

```python
from solace_agent_mesh.gateway.webhook.app import WebhookGatewayApp

# Configuration for webhook gateway
webhook_config = {
    "name": "my-webhook-gateway",
    "namespace": "myorg/prod",
    "gateway_id": "webhook-gateway-01",
    "webhook_host": "0.0.0.0",
    "webhook_port": 9000,
    "webhook_path": "/webhook",
    "target_agent_name": "data-processor",
    "auth_method": "header",
    "auth_header_name": "X-API-Key",
    "auth_header_value": "secret-webhook-key",
    "payload_format": "json",
    "user_id_extraction": {
        "method": "json_path",
        "path": "$.user.id"
    }
}

# Initialize and run the webhook gateway
webhook_app = WebhookGatewayApp(app_info=webhook_config)
webhook_app.run()

# The gateway will:
# - Start an HTTP server on the specified host/port
# - Authenticate incoming requests
# - Extract user identity from payloads
# - Convert webhook data to A2A messages
# - Send to the specified target agent
```

### 6. Working with Task Context Management

```python
from solace_agent_mesh.gateway.base.task_context import TaskContextManager

# Initialize the task context manager (usually done by BaseGat

# content_hash: 8ff3c690b39ed85edd13c1e9f2965e9da9050eeeea66823dbbad322f600f0d09
=======
# Configure Slack gateway
slack_config = {
    "name": "my-slack-bot",
    "namespace": "/myorg/prod",
    "gateway_id": "slack-bot-01",
    
    # Slack credentials (get these from your Slack app)
    "slack_bot_token": "xoxb-your-bot-token",
    "slack_app_token": "xapp-your-app-token",
    "slack_signing_secret": "your-signing-secret",
    
    # Gateway settings
    "default_agent_name": "assistant",
    "enable_socket_mode": True,
    "enable_file_upload": True,
    "slack_request_timeout": 30,
    
    # A2A system configuration
    "solace_config": {
        "broker_url": "tcp://localhost:55555",
        "vpn_name": "default",
        "username": "default",
        "password": "default"
    }
}

# Create and run the Slack gateway
slack_app = SlackGatewayApp(app_info=slack_config)
slack_app.run()
```

### 3. Using the HTTP/SSE Gateway for Web Interfaces

```python
from solace_agent_mesh.gateway.http_sse.app import WebUIBackendApp
from fastapi import APIRouter, Depends, Request
from solace_agent_mesh.gateway.http_sse.dependencies import (
    get_sse_manager, get_session_manager, get_core_a2a_service
)

# Configure web UI gateway
webui_config = {
    "name": "my-webui",
    "session_secret_key": "your-secret-key",
    "fastapi_host": "0.0.0.0",
    "fastapi_port": 8000,
    "namespace": "/myorg/prod",
    "gateway_id": "webui-01",
    "cors_allowed_origins": ["http://localhost:3000"],
    "frontend_welcome_message": "Welcome to AI Assistant!",
    "frontend_bot_name": "Assistant",
    "frontend_enable_file_upload": True,
    "frontend_enable_agent_selection": True,
    
    # Database for session persistence
    "session_service": {
        "type": "sql",
        "database_url": "sqlite:///./sessions.db"
    },
    
    # A2A system configuration
    "solace_config": {
        "broker_url": "tcp://localhost:55555",
        "vpn_name": "default",
        "username": "default",
        "password": "default"
    }
}

# Create custom router for additional endpoints
custom_router = APIRouter(prefix="/api/custom")

@custom_router.get("/my-endpoint")
async def my_custom_endpoint(
    request: Request,
    sse_manager = Depends(get_sse_manager),
    session_manager = Depends(get_session_manager)
):
    """Custom endpoint with access to gateway services."""
    user_id = session_manager.get_a2a_client_id(request)
    return {"user_id": user_id, "message": "Custom endpoint response"}

# Create and run the web UI gateway
webui_app = WebUIBackendApp(app_info=webui_config)
webui_app.run()
```

### 4. Working with Task Context and Session Management

```python
from solace_agent_mesh.gateway.base.task_context import TaskContextManager
from solace_agent_mesh.gateway.http_sse.session_manager import SessionManager

# Task context management (used internally by gateways)
context_manager = TaskContextManager()

# Store context when submitting a task
task_id = "task-123"
context = {
    "platform": "slack",
    "channel_id": "C1234567890",
    "user_id": "U1234567890",
    "thread_ts": "1234567890.123456"
}
context_manager.store_context(task_id, context)

# Retrieve context when processing response
retrieved_context = context_manager.get_context(task_id)
if retrieved_context:
    # Send response back to original platform
    channel_id = retrieved_context["channel_id"]

# Session management for web interfaces
session_manager = SessionManager(
    secret_key="your-secret-key",
    app_config={"session_timeout": 3600}
)

# In a FastAPI endpoint
@app.get("/api/session-info")
async def get_session_info(request: Request):
    # Get A2A client ID for this web session
    client_id = session_manager.get_a2a_client_id(request)
    
    # Ensure we have an A2A session
    session_id = session_manager.ensure_a2a_session(request)
    
    return {
        "client_id": client_id,
        "session_id": session_id
    }
```

### 5. Advanced Integration: Combining Multiple Gateways

```python
import asyncio
from solace_agent_mesh.gateway.slack.app import Sl

# content_hash: 39731f2779a4f0ef42b1948f8441baf5b76eff10fbfc48def5fbb270fa334f6b
>>>>>>> main
