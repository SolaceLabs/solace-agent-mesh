## Developer API Reference

### Direct Files

#### __init__.py
**Purpose:** Serves as the main entry point for the `utils` package, exporting the most common utility functions for easy importing.
**Import:** `from solace_agent_mesh.common.utils import is_text_based_mime_type`

**Classes/Functions/Constants:**
*   `is_text_based_mime_type(mime_type: Optional[str]) -> bool`: Checks if a given MIME type is considered text-based.

#### asyncio_macos_fix.py
**Purpose:** Provides a targeted, automatic fix for a `NotImplementedError` that occurs when creating subprocesses with asyncio on macOS. This module is imported for its side effects and should be loaded early in the application's lifecycle.
**Import:** `from solace_agent_mesh.common.utils import asyncio_macos_fix` (Importing the module is sufficient to apply the patch).

**Classes/Functions/Constants:**
*   `apply_macos_asyncio_fix() -> bool`: Applies the asyncio fix for macOS subprocess support.
*   `ensure_asyncio_compatibility() -> bool`: Ensures asyncio compatibility for subprocess creation on macOS.

#### in_memory_cache.py
**Purpose:** Provides a simple, thread-safe, in-memory cache implemented as a singleton. It's useful for storing frequently accessed data with an optional time-to-live (TTL).
**Import:** `from solace_agent_mesh.common.utils.in_memory_cache import InMemoryCache`

**Classes/Functions/Constants:**
*   **`InMemoryCache`**: A singleton class for caching.
    *   `set(self, key: str, value: Any, ttl: Optional[int] = None) -> None`: Sets a key-value pair with an optional TTL in seconds.
    *   `get(self, key: str, default: Any = None) -> Any`: Retrieves a value by its key, returning a default if the key is not found or has expired.
    *   `delete(self, key: str) -> bool`: Deletes a key-value pair from the cache.
    *   `clear(self) -> bool`: Removes all items from the cache.

#### initializer.py
**Purpose:** Handles initialization of enterprise features if available, loading configuration from environment variables.
**Import:** `from solace_agent_mesh.common.utils.initializer import initialize`

**Classes/Functions/Constants:**
*   `initialize() -> None`: Initializes enterprise features if available, loading configuration from SAM_AUTHORIZATION_CONFIG environment variable.

#### log_formatters.py
**Purpose:** Contains custom logging formatters to structure log output for specific platforms, such as Datadog.
**Import:** `from solace_agent_mesh.common.utils.log_formatters import DatadogJsonFormatter`

**Classes/Functions/Constants:**
*   **`DatadogJsonFormatter(logging.Formatter)`**: A formatter that outputs log records as a JSON string, compatible with Datadog's standard log attributes. It automatically includes tracing information (`dd.trace_id`, `dd.span_id`) if available.

#### message_utils.py
**Purpose:** Provides utilities for calculating and validating message sizes to ensure they don't exceed configured limits.
**Import:** `from solace_agent_mesh.common.utils.message_utils import calculate_message_size, validate_message_size`

**Classes/Functions/Constants:**
*   `calculate_message_size(payload: Dict[str, Any]) -> int`: Calculates the exact size of a message payload in bytes using JSON serialization + UTF-8 encoding.
*   `validate_message_size(payload: Dict[str, Any], max_size_bytes: int, component_identifier: str = "Unknown") -> Tuple[bool, int]`: Validates that a message payload doesn't exceed the maximum size limit.
*   `MAX_UTF8_BYTES_PER_CHARACTER: int`: Maximum bytes per character in UTF-8 encoding (4 bytes).

#### mime_helpers.py
**Purpose:** Provides utilities for handling and classifying MIME types, with a focus on identifying which types represent text-based content.
**Import:** `from solace_agent_mesh.common.utils.mime_helpers import is_text_based_mime_type, get_extension_for_mime_type`

**Classes/Functions/Constants:**
*   `is_text_based_mime_type(mime_type: Optional[str]) -> bool`: Returns `True` if the MIME type starts with `text/` or is in the list of known text-based application types.
*   `is_text_based_file(mime_type: Optional[str], content_bytes: Optional[bytes] = None) -> bool`: Determines if a file is text-based based on its MIME type and content.
*   `get_extension_for_mime_type(mime_type: Optional[str], default_extension: str = ".dat") -> str`: Returns a file extension for a given MIME type.
*   `TEXT_CONTAINER_MIME_TYPES: Set[str]`: A set of non-`text/*` MIME types that are considered to contain text.

#### push_notification_auth.py
**Purpose:** Implements JWT-based authentication for sending and receiving push notifications with request integrity verification.
**Import:** `from solace_agent_mesh.common.utils.push_notification_auth import PushNotificationSenderAuth, PushNotificationReceiverAuth`

**Classes/Functions/Constants:**
*   **`PushNotificationSenderAuth`**: Handles sending authenticated push notifications.
    *   `generate_jwk(self) -> None`: Generates RSA key pair for signing.
    *   `handle_jwks_endpoint(self, request: Request) -> JSONResponse`: Returns public keys for client verification.
    *   `send_push_notification(self, url: str, data: dict[str, Any]) -> None`: Sends authenticated push notification.
    *   `verify_push_notification_url(url: str) -> bool`: Verifies a push notification URL.
*   **`PushNotificationReceiverAuth`**: Handles receiving and verifying authenticated push notifications.
    *   `load_jwks(self, jwks_url: str) -> None`: Loads public keys from JWKS endpoint.
    *   `verify_push_notification(self, request: Request) -> bool`: Verifies incoming push notification authenticity.

### Subdirectory APIs

#### embeds/
**Purpose:** Provides a comprehensive system for finding, parsing, and resolving embedded dynamic expressions within strings using `«...»` syntax.
**Key Exports:** Main functions for embed resolution, evaluation, and constants for embed syntax.
**Import Examples:**
```python
from solace_agent_mesh.common.utils.embeds import resolve_embeds_recursively_in_string, evaluate_embed, EMBED_REGEX
from solace_agent_mesh.common.utils.embeds.constants import EARLY_EMBED_TYPES, LATE_EMBED_TYPES
from solace_agent_mesh.common.utils.embeds.types import DataFormat
```

## Complete Usage Guide

### 1. Basic Utility Imports and Usage

```python
# Import commonly used utilities
from solace_agent_mesh.common.utils import is_text_based_mime_type
from solace_agent_mesh.common.utils.in_memory_cache import InMemoryCache
from solace_agent_mesh.common.utils.message_utils import validate_message_size
from solace_agent_mesh.common.utils.mime_helpers import get_extension_for_mime_type

# Check if content type is text-based
if is_text_based_mime_type("application/json"):
    print("JSON is text-based")

# Use singleton cache
cache = InMemoryCache()
cache.set("user_data", {"name": "Alice"}, ttl=300)  # 5 minute TTL
user_data = cache.get("user_data", {})

# Validate message size
payload = {"message": "Hello world", "data": [1, 2, 3]}
is_valid, size = validate_message_size(payload, max_size_bytes=1024)
if not is_valid:
    print(f"Message too large: {size} bytes")

# Get file extension from MIME type
extension = get_extension_for_mime_type("image/png")  # Returns ".png"
```

### 2. Platform Compatibility and Initialization

```python
# Early in your application startup
from solace_agent_mesh.common.utils import asyncio_macos_fix  # Auto-applies fix
from solace_agent_mesh.common.utils.initializer import initialize

# Initialize enterprise features if available
initialize()

# Now asyncio subprocess creation will work on macOS
import asyncio
async def run_subprocess():
    process = await asyncio.create_subprocess_exec("echo", "hello")
    await process.wait()
```

### 3. Custom Logging Setup

```python
import logging
from solace_agent_mesh.common.utils.log_formatters import DatadogJsonFormatter

# Set up Datadog-compatible JSON logging
logger = logging.getLogger("my_app")
handler = logging.StreamHandler()
handler.setFormatter(DatadogJsonFormatter())
logger.addHandler(handler)
logger.setLevel(logging.INFO)

# Logs will be formatted as JSON with Datadog attributes
logger.info("User logged in", extra={"user_id": "123", "dd.trace_id": "abc"})
```

### 4. Push Notification Authentication

```python
from solace_agent_mesh.common.utils.push_notification_auth import (
    PushNotificationSenderAuth, 
    PushNotificationReceiverAuth
)
from starlette.applications import Starlette
from starlette.requests import Request
from starlette.responses import Response

# Sender setup
sender_auth = PushNotificationSenderAuth()
sender_auth.generate_jwk()

# Verify and send notification
url = "https://client.example.com/webhook"
if await sender_auth.verify_push_notification_url(url):
    await sender_auth.send_push_notification(url, {"event": "update", "data": "value"})

# Receiver setup
app = Starlette()
receiver_auth = PushNotificationReceiverAuth()
await receiver_auth.load_jwks("https://sender.example.com/.well-known/jwks.json")

@app.route("/webhook", methods=["POST"])
async def webhook(request: Request):
    if await receiver_auth.verify_push_notification(request):
        # Process authenticated notification
        data = await request.json()
        return Response("OK")
    return Response("Unauthorized", status_code=401)

# JWKS endpoint for sender
@app.route("/.well-known/jwks.json")
async def jwks(request: Request):
    return sender_auth.handle_jwks_endpoint(request)
```

### 5. Advanced Embed Processing

```python
from solace_agent_mesh.common.utils.embeds import (
    resolve_embeds_recursively_in_string, 
    evaluate_embed,
    EARLY_EMBED_TYPES,
    LATE_EMBED_TYPES
)

# Set up context for embed resolution
context = {
    "artifact_service": my_artifact_service,
    "session_context": {
        "app_name": "myapp",
        "user_id": "user123", 
        "session_id": "sess456"
    }
}

# Simple embed resolution
text = """
Current time: «datetime:%Y-%m-%d %H:%M:%S»
Calculation: «math:10 * 1.15 | .2f»
Unique ID: «uuid:new»
"""

resolved = await resolve_embeds_recursively_in_string(
    text=text,
    context=context,
    resolver_func=evaluate_embed,
    types_to_resolve=EARLY_EMBED_TYPES,
    log_identifier="[MyApp]",
    config={},
    max_depth=5
)

# Complex artifact content processing
artifact_text = """
Sales Report:
«artifact_content:sales.csv:1 >>> select_cols:product,revenue >>> filter_rows_eq:category:electronics >>> format:json_pretty»

Summary: «artifact_content:summary.txt >>> head:5»
"""

final_result = await resolve_embeds_recursively_in_string(
    text=artifact_text,
    context=context,
    resolver_func=evaluate_embed,
    types_to_resolve=LATE_EMBED_TYPES,
    log_identifier="[Report]",
    config={"max_artifact_size": 1024*1024},
    max_depth=3
)
```

### 6. Integrated Workflow Example

```python
from solace_agent_mesh.common.utils import is_text_based_mime_type
from solace_agent_mesh.common.utils.in_memory_cache import InMemoryCache
from solace_agent_mesh.common.utils.message_utils import validate_message_size
from solace_agent_mesh.common.utils.embeds import resolve_embeds_recursively_in_string, evaluate_embed

async def process_user_request(user_id: str, template: str, context: dict):
    """Complete workflow using multiple utils together."""
    
    # Get cache instance
    cache = InMemoryCache()
    
    # Check cache first
    cache_key = f"processed_template_{user_id}_{hash(template)}"
    cached_result = cache.get(cache_key)
    if cached_result:
        return cached_result
    
    # Process embeds in template
    full_context = {
        **context,
        "session_context": {"user_id": user_id}
    }
    
    processed_text = await resolve_embeds_recursively_in_string(
        text=template,
        context=full_context,
        resolver_func=evaluate_embed,
        types_to_resolve={"math", "datetime", "uuid", "artifact_content"},
        log_identifier=f"[User:{user_id}]",
        config={},
        max_depth=5
    )
    
    # Validate result size
    result_payload = {"processed_text": processed_text, "user_id": user_id}
    is_valid, size = validate_message_size(result_payload, max_size_bytes=10*1024*1024)
    
    if not is_valid:
        raise ValueError(f"Processed result too large: {size} bytes")
    
    # Cache result for 10 minutes
    cache.set(cache_key, processed_text, ttl=600)
    
    return processed_text

# Usage
template = """
Hello! Today is «datetime:%Y-%m-%d».
Your order total: «math:«artifact_content:cart.json >>> jsonpath:$.total» * 1.08 | .2f»
Order ID: «uuid:new»
"""

result = await process_user_request("user123", template, {"artifact_service": service})
```

This comprehensive guide shows how the `utils` directory provides essential building blocks that work together to create robust, dynamic applications with caching, security, platform compatibility, and advanced content processing capabilities.

# content_hash: c81d0ce65418094841137a435b82562156225f13e9ccb949474aa23ac5ff9a47
