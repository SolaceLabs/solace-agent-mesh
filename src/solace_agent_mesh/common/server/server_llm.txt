# DEVELOPER GUIDE: server

## Quick Summary
The `server` directory provides a complete Agent-to-Agent (A2A) communication server implementation built on Starlette. It implements JSON-RPC 2.0 protocol for handling task-related requests, supports both standard request-response and streaming via Server-Sent Events (SSE), and includes an extensible task management system with push notification capabilities.

## Files Overview
- `__init__.py` - Exposes main public classes for easy import
- `server.py` - Core HTTP server implementation with JSON-RPC request routing
- `task_manager.py` - Abstract task manager interface and in-memory implementation
- `utils.py` - Utility functions for error responses and modality compatibility checks

## Developer API Reference

### __init__.py
**Purpose:** Provides convenient access to the main server components
**Import:** `from solace_agent_mesh.common.server import A2AServer, TaskManager, InMemoryTaskManager`

### server.py
**Purpose:** Main HTTP server that handles A2A communication via JSON-RPC 2.0 protocol
**Import:** `from solace_agent_mesh.common.server import A2AServer`

**Classes:**
- `A2AServer(host: str = "0.0.0.0", port: int = 5000, endpoint: str = "/", agent_card: AgentCard = None, task_manager: TaskManager = None)` - Starlette-based web server for A2A communication
  - `start() -> None` - Starts the uvicorn server (raises ValueError if agent_card or task_manager not set)
  - `host: str` - Server bind address
  - `port: int` - Server port
  - `endpoint: str` - Main API endpoint path
  - `agent_card: AgentCard` - Agent metadata served at `/.well-known/agent.json`
  - `task_manager: TaskManager` - Handler for task operations

**Usage Examples:**
```python
from solace_agent_mesh.common.server import A2AServer, InMemoryTaskManager
from solace_agent_mesh.common.types import AgentCard, SendTaskRequest, SendTaskResponse

# Define agent capabilities
agent_card = AgentCard(
    id="my-agent-v1",
    name="My Agent",
    version="1.0.0",
    description="A sample agent",
    supported_tasks=["summarize"],
    input_modalities=["text/plain"],
    output_modalities=["text/plain"]
)

# Create custom task manager
class MyTaskManager(InMemoryTaskManager):
    async def on_send_task(self, request: SendTaskRequest) -> SendTaskResponse:
        task = await self.upsert_task(request.params)
        # Process task here
        return SendTaskResponse(id=request.id, result=task)
    
    async def on_send_task_subscribe(self, request):
        # Handle streaming tasks
        pass

# Start server
server = A2AServer(
    host="127.0.0.1",
    port=8080,
    agent_card=agent_card,
    task_manager=MyTaskManager()
)
server.start()
```

### task_manager.py
**Purpose:** Defines task management interface and provides in-memory implementation
**Import:** `from solace_agent_mesh.common.server import TaskManager, InMemoryTaskManager`

**Classes:**
- `TaskManager()` - Abstract base class defining task operation interface
  - `on_get_task(request: GetTaskRequest) -> GetTaskResponse` - Retrieve task status and details
  - `on_cancel_task(request: CancelTaskRequest) -> CancelTaskResponse` - Cancel an ongoing task
  - `on_send_task(request: SendTaskRequest) -> SendTaskResponse` - Handle standard task submission
  - `on_send_task_subscribe(request: SendTaskStreamingRequest) -> Union[AsyncIterable[SendTaskStreamingResponse], JSONRPCResponse]` - Handle streaming task submission
  - `on_set_task_push_notification(request: SetTaskPushNotificationRequest) -> SetTaskPushNotificationResponse` - Configure push notifications
  - `on_get_task_push_notification(request: GetTaskPushNotificationRequest) -> GetTaskPushNotificationResponse` - Get push notification config
  - `on_resubscribe_to_task(request: TaskResubscriptionRequest) -> Union[AsyncIterable[SendTaskResponse], JSONRPCResponse]` - Resubscribe to streaming task

- `InMemoryTaskManager()` - Concrete implementation with in-memory storage and SSE support
  - `upsert_task(task_send_params: TaskSendParams) -> Task` - Create or update task with new message
  - `update_store(task_id: str, status: TaskStatus, artifacts: list[Artifact]) -> Task` - Update task status and artifacts
  - `set_push_notification_info(task_id: str, notification_config: PushNotificationConfig) -> None` - Store push notification config
  - `get_push_notification_info(task_id: str) -> PushNotificationConfig` - Retrieve push notification config
  - `has_push_notification_info(task_id: str) -> bool` - Check if push notification config exists
  - `setup_sse_consumer(task_id: str, is_resubscribe: bool = False) -> asyncio.Queue` - Create SSE subscriber queue
  - `enqueue_events_for_sse(task_id: str, task_update_event: Any) -> None` - Send event to all SSE subscribers
  - `dequeue_events_for_sse(request_id: str, task_id: str, sse_event_queue: asyncio.Queue) -> AsyncIterable[SendTaskStreamingResponse]` - Async generator for SSE events

**Usage Examples:**
```python
import asyncio
from solace_agent_mesh.common.server import InMemoryTaskManager
from solace_agent_mesh.common.types import (
    SendTaskRequest, SendTaskResponse, SendTaskStreamingRequest,
    TaskStatus, TaskState, TaskStatusUpdateEvent
)

class CustomTaskManager(InMemoryTaskManager):
    async def on_send_task(self, request: SendTaskRequest) -> SendTaskResponse:
        # Create/update task
        task = await self.upsert_task(request.params)
        
        # Process task
        result = f"Processed: {request.params.message.content}"
        
        # Update status
        status = TaskStatus(state=TaskState.COMPLETED)
        await self.update_store(task.id, status, [])
        
        return SendTaskResponse(id=request.id, result=task)
    
    async def on_send_task_subscribe(self, request: SendTaskStreamingRequest):
        await self.upsert_task(request.params)
        sse_queue = await self.setup_sse_consumer(request.params.id)
        
        # Start background processing
        asyncio.create_task(self._process_streaming(request.params.id))
        
        return self.dequeue_events_for_sse(request.id, request.params.id, sse_queue)
    
    async def _process_streaming(self, task_id: str):
        for i in range(3):
            await asyncio.sleep(1)
            event = TaskStatusUpdateEvent(
                status=TaskStatus(state=TaskState.IN_PROGRESS),
                message={"content": f"Step {i+1}"}
            )
            await self.enqueue_events_for_sse(task_id, event)
        
        # Final event
        final_event = TaskStatusUpdateEvent(
            status=TaskStatus(state=TaskState.COMPLETED),
            final=True
        )
        await self.enqueue_events_for_sse(task_id, final_event)
```

### utils.py
**Purpose:** Utility functions for error handling and compatibility checks
**Import:** `from solace_agent_mesh.common.server.utils import are_modalities_compatible, new_incompatible_types_error, new_not_implemented_error`

**Functions:**
- `are_modalities_compatible(server_output_modes: List[str], client_output_modes: List[str]) -> bool` - Check if modality lists have common elements
- `new_incompatible_types_error(request_id) -> JSONRPCResponse` - Create content type not supported error response
- `new_not_implemented_error(request_id) -> JSONRPCResponse` - Create unsupported operation error response

**Usage Examples:**
```python
from solace_agent_mesh.common.server.utils import are_modalities_compatible, new_not_implemented_error

# Check modality compatibility
server_modes = ["text/plain", "application/json"]
client_modes = ["text/plain"]
compatible = are_modalities_compatible(server_modes, client_modes)  # True

# Create error responses
error_response = new_not_implemented_error("request-123")
```

# content_hash: 0c17c4e0887c76ab8302a54f91fb714956b040c181af103198193442fe18697f
