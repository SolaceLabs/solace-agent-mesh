"""
Solace broker client for the Skill Learning Service.

This module provides a Solace client that uses the solace-ai-connector
library (same as the rest of SAM) for broker communication.

For local development without a broker, use the MockSolaceClient.
"""

import logging
import json
import threading
import queue
import time
from typing import Optional, Callable, Dict, Any, List
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class SolaceBrokerConfig:
    """Configuration for Solace broker connection."""
    
    broker_url: str
    vpn_name: str
    username: str
    password: str
    queue_name: str = "sam/skill-learning/queue"
    dev_mode: bool = False
    namespace: str = "default_namespace/"
    
    @classmethod
    def from_env(cls) -> "SolaceBrokerConfig":
        """Create configuration from environment variables.
        
        Uses SAM standard env vars (SOLACE_BROKER_*).
        """
        import os
        
        return cls(
            broker_url=os.environ.get("SOLACE_BROKER_URL", "ws://localhost:8008"),
            vpn_name=os.environ.get("SOLACE_BROKER_VPN", "default"),
            username=os.environ.get("SOLACE_BROKER_USERNAME", "default"),
            password=os.environ.get("SOLACE_BROKER_PASSWORD", "default"),
            queue_name=os.environ.get("SKILL_LEARNING_QUEUE", "sam/skill-learning/queue"),
            dev_mode=os.environ.get("SOLACE_DEV_MODE", "false").lower() == "true",
            namespace=os.environ.get("NAMESPACE", "default_namespace/"),
        )



class SACSkillLearningClient:
    """
    Solace client using solace-ai-connector (SAC) for the Skill Learning Service.
    
    This client creates a proper SAC connector with an app that has a broker_input
    component to receive messages from the Solace broker.
    """
    
    def __init__(
        self,
        config: SolaceBrokerConfig,
        message_callback: Callable[[str, Dict[str, Any]], Optional[Dict[str, Any]]],
    ):
        """
        Initialize the SAC-based Solace client.
        
        Args:
            config: Broker configuration
            message_callback: Callback for handling messages (topic, payload) -> response
        """
        self.config = config
        self.message_callback = message_callback
        
        self._connector = None
        self._message_queue: queue.Queue = queue.Queue(maxsize=200)
        self._processor_thread: Optional[threading.Thread] = None
        self._running = False
        self._stop_event = threading.Event()
    
    def connect(self) -> bool:
        """
        Connect to the Solace broker using SAC.
        
        Note: This just validates the configuration. Actual connection
        happens in start_receiving() when we create the SAC app.
        
        Returns:
            True if configuration is valid
        """
        try:
            # Validate that SAC is available
            from solace_ai_connector.solace_ai_connector import SolaceAiConnector
            
            logger.info(f"SAC available, will connect to broker at {self.config.broker_url}")
            return True
            
        except ImportError as e:
            logger.error(f"solace-ai-connector not available: {e}")
            return False
        except Exception as e:
            logger.error(f"Failed to validate broker configuration: {e}")
            return False
    
    def start_receiving(self, subscriptions: List[str]) -> bool:
        """
        Start receiving messages from the broker.
        
        Creates a SAC connector with an app that subscribes to the given topics.
        
        Args:
            subscriptions: List of topic subscription patterns
            
        Returns:
            True if started successfully
        """
        try:
            from solace_ai_connector.solace_ai_connector import SolaceAiConnector
            
            logger.info(f"Starting SAC connector with subscriptions: {subscriptions}")
            
            # Import the forwarder component
            from .forwarder_component import SkillLearningForwarderComponent
            
            # Create broker input component configuration
            # The broker config MUST be in component_config for the broker_input component
            # This is how SAC validates and uses the broker connection settings
            #
            # IMPORTANT: We use a temporary queue (no queue name specified) to avoid
            # "Max clients exceeded for queue" errors when restarting the service.
            # Temporary queues are auto-generated by the broker and cleaned up on disconnect.
            broker_input_cfg = {
                "component_module": "broker_input",
                "component_name": "skill_learning_broker_input",
                # Don't specify broker_queue_name for temporary queues - let broker auto-generate
                "create_queue_on_start": True,
                "component_config": {
                    "broker_url": self.config.broker_url,
                    "broker_username": self.config.username,
                    "broker_password": self.config.password,
                    "broker_vpn": self.config.vpn_name,
                    "dev_mode": self.config.dev_mode,
                    "temporary_queue": True,
                    "broker_subscriptions": [{"topic": sub} for sub in subscriptions],
                },
            }
            
            # Create forwarder component configuration
            forwarder_cfg = {
                "component_class": SkillLearningForwarderComponent,
                "component_name": "skill_learning_forwarder",
                "component_config": {
                    "target_queue_ref": self._message_queue,
                },
            }
            
            # Create flow configuration
            flow_config = {
                "name": "skill_learning_flow",
                "components": [broker_input_cfg, forwarder_cfg],
            }
            
            # Create app configuration
            # Note: For standalone connectors, broker config goes in component_config
            # The app-level broker is only used when creating internal apps from an existing connector
            app_config = {
                "name": "SkillLearningApp",
                "flows": [flow_config],
            }
            
            # Create connector configuration with the app
            connector_config = {
                "log": {
                    "log_file_level": "INFO",
                    "stdout_log_level": "INFO",
                },
                "apps": [app_config],
            }
            
            # Log the full config for debugging
            import json
            logger.info(f"SAC connector config: {json.dumps(connector_config, indent=2, default=str)}")
            
            # Create and run the connector
            self._connector = SolaceAiConnector(config=connector_config)
            self._connector.run()
            
            logger.info(f"SAC connector started, subscribed to: {subscriptions}")
            
            # Start message processor thread
            self._running = True
            self._processor_thread = threading.Thread(
                target=self._message_processor_loop,
                name="SkillLearningMessageProcessor",
                daemon=True,
            )
            self._processor_thread.start()
            
            logger.info("Started receiving messages")
            return True
            
        except Exception as e:
            logger.error(f"Failed to start receiving: {e}", exc_info=True)
            return False
    
    def _message_processor_loop(self):
        """Process messages from the message queue."""
        logger.info("Message processor loop started")
        
        while not self._stop_event.is_set():
            try:
                # Get message from queue with timeout
                try:
                    msg_data = self._message_queue.get(timeout=1.0)
                except queue.Empty:
                    continue
                
                if msg_data is None:
                    # Shutdown signal
                    break
                
                topic = msg_data.get("topic", "")
                payload = msg_data.get("payload", {})
                
                logger.debug(f"Processing message from {topic}")
                
                # Call the message callback
                try:
                    self.message_callback(topic, payload)
                except Exception as e:
                    logger.error(f"Error in message callback: {e}")
                
                self._message_queue.task_done()
                    
            except Exception as e:
                if not self._stop_event.is_set():
                    logger.error(f"Error in message processor: {e}")
                    time.sleep(1)
        
        logger.info("Message processor loop stopped")
    
    def start_publishing(self) -> bool:
        """
        Start the message publisher.
        
        Returns:
            True if started successfully
        """
        # Publishing is handled through the SAC connector
        logger.info("Publisher ready (using SAC)")
        return True
    
    def publish(self, topic: str, payload: Dict[str, Any]) -> bool:
        """
        Publish a message to a topic.
        
        Args:
            topic: The topic to publish to
            payload: The message payload
            
        Returns:
            True if published successfully
        """
        if not self._connector:
            logger.error("Connector not started")
            return False
        
        try:
            # Note: For now, skill learning service is receive-only
            # If publishing is needed, we would need to add a broker_output component
            logger.debug(f"Would publish message to {topic}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to publish message to {topic}: {e}")
            return False
    
    def stop(self):
        """Stop the client and disconnect from the broker."""
        logger.info("Stopping SAC client")
        self._running = False
        self._stop_event.set()
        
        # Signal the processor thread to stop
        try:
            self._message_queue.put(None)
        except Exception:
            pass
        
        if self._processor_thread and self._processor_thread.is_alive():
            self._processor_thread.join(timeout=5)
        
        if self._connector:
            try:
                self._connector.stop()
                self._connector.cleanup()
            except Exception as e:
                logger.error(f"Error cleaning up connector: {e}")
            self._connector = None
        
        logger.info("SAC client stopped")
    
    @property
    def is_running(self) -> bool:
        """Check if the client is running."""
        return self._running


class MockSolaceClient:
    """
    Mock Solace client for testing without a broker.
    
    This client simulates broker behavior for local development.
    """
    
    def __init__(
        self,
        config: SolaceBrokerConfig,
        message_callback: Callable[[str, Dict[str, Any]], Optional[Dict[str, Any]]],
    ):
        self.config = config
        self.message_callback = message_callback
        self._running = False
        self._published_messages: List[tuple] = []
    
    def connect(self) -> bool:
        logger.info("[MOCK] Connected to mock Solace broker")
        return True
    
    def start_receiving(self, subscriptions: List[str]) -> bool:
        logger.info(f"[MOCK] Subscribed to: {subscriptions}")
        self._running = True
        return True
    
    def start_publishing(self) -> bool:
        logger.info("[MOCK] Started mock publisher")
        return True
    
    def publish(self, topic: str, payload: Dict[str, Any]) -> bool:
        logger.info(f"[MOCK] Published to {topic}: {json.dumps(payload)[:100]}...")
        self._published_messages.append((topic, payload))
        return True
    
    def stop(self):
        logger.info("[MOCK] Stopped mock client")
        self._running = False
    
    @property
    def is_running(self) -> bool:
        return self._running
    
    def simulate_message(self, topic: str, payload: Dict[str, Any]):
        """Simulate receiving a message (for testing)."""
        logger.info(f"[MOCK] Simulating message on {topic}")
        self.message_callback(topic, payload)


def create_solace_client(
    config: SolaceBrokerConfig,
    message_callback: Callable[[str, Dict[str, Any]], Optional[Dict[str, Any]]],
    use_mock: bool = False,
) -> SACSkillLearningClient | MockSolaceClient:
    """
    Create a Solace client.
    
    Args:
        config: Broker configuration
        message_callback: Message handler callback
        use_mock: Whether to use mock client
        
    Returns:
        Solace client instance
    """
    if use_mock:
        logger.info("Using mock Solace client")
        return MockSolaceClient(config, message_callback)
    
    # Try to use SAC client
    try:
        from solace_ai_connector.flow.app import App as SACApp
        return SACSkillLearningClient(config, message_callback)
    except ImportError:
        logger.warning("solace-ai-connector not available, using mock client")
        return MockSolaceClient(config, message_callback)


# Keep old names for backward compatibility
SolaceSkillLearningClient = SACSkillLearningClient