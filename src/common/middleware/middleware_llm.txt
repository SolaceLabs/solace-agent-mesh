# DEVELOPER GUIDE: middleware

## Quick Summary
The `middleware` directory provides a pluggable framework for system components that can be extended or replaced at runtime. It offers a registry system to dynamically bind custom implementations for core functionalities like configuration resolution. The default implementations provide permissive behavior, making them suitable for development and testing environments where all features are enabled by default.

## Files Overview
- `__init__.py` - Exposes the main public classes of the middleware package for easy importing
- `config_resolver.py` - Defines the default, permissive configuration resolution middleware
- `registry.py` - Provides the MiddlewareRegistry for dynamically binding custom middleware implementations

## Developer API Reference

### __init__.py
**Purpose:** Entry point to the middleware package, exporting the primary public interfaces

**Import:** `from solace_ai_connector.common.middleware import ConfigResolver, MiddlewareRegistry`

**Usage Examples:**
```python
# Import the main classes directly from the middleware package
from solace_ai_connector.common.middleware import ConfigResolver, MiddlewareRegistry

# Now you can use ConfigResolver and MiddlewareRegistry
resolver = ConfigResolver()
registry = MiddlewareRegistry()
```

### config_resolver.py
**Purpose:** Provides a pluggable interface for resolving user-specific configuration and determining feature availability. The default implementation is permissive, allowing all operations.

**Import:** `from solace_ai_connector.common.middleware import ConfigResolver`

**Classes:**
- `ConfigResolver()` - Resolves user-specific configuration and determines feature availability with permissive defaults
  - `resolve_user_config(user_identity: Any, gateway_context: Dict[str, Any], base_config: Dict[str, Any]) -> Dict[str, Any]` - (async static) Resolves user-specific configuration settings
  - `is_feature_enabled(user_config: Dict[str, Any], feature_descriptor: Dict[str, Any], context: Dict[str, Any]) -> bool` - (static) Checks if a feature is enabled for the user
  - `validate_operation_config(user_config: Dict[str, Any], operation_spec: Dict[str, Any], validation_context: Dict[str, Any]) -> Dict[str, Any]` - (static) Validates operation against user configuration
  - `filter_available_options(user_config: Dict[str, Any], available_options: List[Dict[str, Any]], filter_context: Dict[str, Any]) -> List[Dict[str, Any]]` - (static) Filters available options based on user configuration

**Usage Examples:**
```python
import asyncio
from solace_ai_connector.common.middleware import ConfigResolver

async def main():
    # Resolve user configuration
    user_config = await ConfigResolver.resolve_user_config(
        user_identity="user@example.com",
        gateway_context={"gateway_id": "gw-1"},
        base_config={"api_key": "default_key"}
    )
    
    # Check if feature is enabled
    feature_enabled = ConfigResolver.is_feature_enabled(
        user_config=user_config,
        feature_descriptor={"feature_type": "ai_tool", "function_name": "code_interpreter"},
        context={}
    )
    
    # Validate operation
    validation_result = ConfigResolver.validate_operation_config(
        user_config=user_config,
        operation_spec={"operation_type": "model_inference", "model": "gpt-4"},
        validation_context={}
    )
    
    # Filter available options
    filtered_options = ConfigResolver.filter_available_options(
        user_config=user_config,
        available_options=[{"name": "gpt-3.5"}, {"name": "gpt-4"}],
        filter_context={"type": "language_model"}
    )

asyncio.run(main())
```

### registry.py
**Purpose:** Provides a registry system for dynamically binding custom middleware implementations at runtime

**Import:** `from solace_ai_connector.common.middleware import MiddlewareRegistry`

**Classes:**
- `MiddlewareRegistry()` - Registry for managing middleware implementations with class methods
  - `bind_config_resolver(resolver_class: Type)` - (classmethod) Binds a custom config resolver implementation
  - `get_config_resolver() -> Type` - (classmethod) Gets the current config resolver implementation
  - `register_initialization_callback(callback: callable)` - (classmethod) Registers a callback for system initialization
  - `initialize_middleware()` - (classmethod) Initializes all registered middleware components
  - `reset_bindings()` - (classmethod) Resets all bindings to defaults
  - `get_registry_status() -> Dict[str, Any]` - (classmethod) Gets current status of the middleware registry

**Usage Examples:**
```python
from solace_ai_connector.common.middleware import MiddlewareRegistry, ConfigResolver
from typing import Any, Dict

# Define custom config resolver
class CustomConfigResolver:
    @staticmethod
    async def resolve_user_config(user_identity: Any, gateway_context: Dict[str, Any], base_config: Dict[str, Any]) -> Dict[str, Any]:
        # Custom logic here
        return {"custom": True, **base_config}
    
    # Inherit other methods from default
    is_feature_enabled = ConfigResolver.is_feature_enabled
    validate_operation_config = ConfigResolver.validate_operation_config
    filter_available_options = ConfigResolver.filter_available_options

# Define initialization callback
def setup_custom_middleware():
    print("Setting up custom middleware...")

# Bind custom implementations
MiddlewareRegistry.bind_config_resolver(CustomConfigResolver)
MiddlewareRegistry.register_initialization_callback(setup_custom_middleware)

# Initialize middleware (call during app startup)
MiddlewareRegistry.initialize_middleware()

# Get current resolver
current_resolver = MiddlewareRegistry.get_config_resolver()

# Check registry status
status = MiddlewareRegistry.get_registry_status()
print(f"Registry status: {status}")

# Reset for testing
MiddlewareRegistry.reset_bindings()
```

# content_hash: 62bfccb5a13cdb8430b367f663dfdc10c4ee0a494d5d781f51e4ebbeac6a5ab8
