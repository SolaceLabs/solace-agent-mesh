# DEVELOPER GUIDE for server

## Quick Summary
The `server` directory provides a complete Agent-to-Agent (A2A) communication server built on Starlette that implements JSON-RPC 2.0 protocol. It handles task management, streaming responses via Server-Sent Events (SSE), push notifications, and agent discovery through standardized endpoints.

## Files Overview
- `__init__.py` - Exposes main public classes for easy importing
- `server.py` - Core A2A HTTP server implementation with JSON-RPC request routing
- `task_manager.py` - Abstract task management interface and in-memory implementation
- `utils.py` - Utility functions for error responses and modality compatibility checks

## Developer API Reference

### __init__.py
**Purpose:** Provides convenient access to the main server components
**Import:** `from solace_ai_connector.common.server import A2AServer, TaskManager, InMemoryTaskManager`

### server.py
**Purpose:** Main HTTP server that handles A2A communication via JSON-RPC 2.0 protocol
**Import:** `from solace_ai_connector.common.server import A2AServer`

**Classes:**
- `A2AServer(host: str = "0.0.0.0", port: int = 5000, endpoint: str = "/", agent_card: AgentCard = None, task_manager: TaskManager = None)` - Starlette-based web server for A2A communication
  - `start() -> None` - Starts the uvicorn server (raises ValueError if agent_card or task_manager not set)
  - `host: str` - Server bind address
  - `port: int` - Server port number
  - `endpoint: str` - Main API endpoint path
  - `agent_card: AgentCard` - Agent metadata served at `/.well-known/agent.json`
  - `task_manager: TaskManager` - Handler for task operations

**Usage Examples:**
```python
from solace_ai_connector.common.server import A2AServer, InMemoryTaskManager
from solace_ai_connector.common.types import AgentCard

# Create agent metadata
agent_card = AgentCard(
    id="my-agent-v1",
    name="My Agent",
    version="1.0.0",
    description="A sample agent",
    supported_tasks=["summarize"],
    input_modalities=["text/plain"],
    output_modalities=["text/plain"]
)

# Create custom task manager
class MyTaskManager(InMemoryTaskManager):
    async def on_send_task(self, request):
        # Your agent logic here
        task = await self.upsert_task(request.params)
        # Process task...
        return SendTaskResponse(id=request.id, result=task)

# Start server
server = A2AServer(
    host="127.0.0.1",
    port=8080,
    agent_card=agent_card,
    task_manager=MyTaskManager()
)
server.start()
```

### task_manager.py
**Purpose:** Defines task management interface and provides in-memory implementation
**Import:** `from solace_ai_connector.common.server import TaskManager, InMemoryTaskManager`

**Classes:**
- `TaskManager()` - Abstract base class defining task management interface
  - `on_get_task(request: GetTaskRequest) -> GetTaskResponse` - Retrieve task status and details
  - `on_cancel_task(request: CancelTaskRequest) -> CancelTaskResponse` - Cancel an ongoing task
  - `on_send_task(request: SendTaskRequest) -> SendTaskResponse` - Handle standard task submission
  - `on_send_task_subscribe(request: SendTaskStreamingRequest) -> Union[AsyncIterable[SendTaskStreamingResponse], JSONRPCResponse]` - Handle streaming task submission
  - `on_set_task_push_notification(request: SetTaskPushNotificationRequest) -> SetTaskPushNotificationResponse` - Configure push notifications
  - `on_get_task_push_notification(request: GetTaskPushNotificationRequest) -> GetTaskPushNotificationResponse` - Get push notification config
  - `on_resubscribe_to_task(request: TaskResubscriptionRequest) -> Union[AsyncIterable[SendTaskResponse], JSONRPCResponse]` - Resubscribe to streaming task

- `InMemoryTaskManager()` - Concrete implementation with in-memory storage and SSE support
  - `upsert_task(task_send_params: TaskSendParams) -> Task` - Create or update task with new message
  - `update_store(task_id: str, status: TaskStatus, artifacts: list[Artifact]) -> Task` - Update task status and artifacts
  - `set_push_notification_info(task_id: str, notification_config: PushNotificationConfig) -> None` - Store push notification config
  - `get_push_notification_info(task_id: str) -> PushNotificationConfig` - Retrieve push notification config
  - `has_push_notification_info(task_id: str) -> bool` - Check if push notification config exists
  - `setup_sse_consumer(task_id: str, is_resubscribe: bool = False) -> asyncio.Queue` - Create SSE subscriber queue
  - `enqueue_events_for_sse(task_id: str, task_update_event: Any) -> None` - Send event to all SSE subscribers
  - `dequeue_events_for_sse(request_id: str, task_id: str, sse_event_queue: asyncio.Queue) -> AsyncIterable[SendTaskStreamingResponse]` - Async generator for SSE events

**Usage Examples:**
```python
import asyncio
from solace_ai_connector.common.server import InMemoryTaskManager
from solace_ai_connector.common.types import (
    SendTaskRequest, SendTaskResponse, TaskStatus, TaskState,
    SendTaskStreamingRequest, TaskStatusUpdateEvent
)

class MyTaskManager(InMemoryTaskManager):
    async def on_send_task(self, request: SendTaskRequest) -> SendTaskResponse:
        # Create/update task
        task = await self.upsert_task(request.params)
        
        # Process task (your logic here)
        result = f"Processed: {request.params.message.content}"
        
        # Update task as completed
        status = TaskStatus(state=TaskState.COMPLETED)
        await self.update_store(task.id, status, [])
        
        return SendTaskResponse(id=request.id, result=task)

    async def on_send_task_subscribe(self, request: SendTaskStreamingRequest):
        await self.upsert_task(request.params)
        sse_queue = await self.setup_sse_consumer(request.params.id)
        
        # Start background processing
        asyncio.create_task(self._process_streaming(request.params.id))
        
        # Return SSE generator
        return self.dequeue_events_for_sse(request.id, request.params.id, sse_queue)
    
    async def _process_streaming(self, task_id: str):
        for i in range(3):
            await asyncio.sleep(1)
            event = TaskStatusUpdateEvent(
                status=TaskStatus(state=TaskState.IN_PROGRESS),
                message={"content": f"Step {i+1} complete"}
            )
            await self.enqueue_events_for_sse(task_id, event)
        
        # Final event
        final_event = TaskStatusUpdateEvent(
            status=TaskStatus(state=TaskState.COMPLETED),
            final=True
        )
        await self.enqueue_events_for_sse(task_id, final_event)
```

### utils.py
**Purpose:** Utility functions for error handling and compatibility checks
**Import:** `from solace_ai_connector.common.server.utils import are_modalities_compatible, new_incompatible_types_error, new_not_implemented_error`

**Functions:**
- `are_modalities_compatible(server_output_modes: List[str], client_output_modes: List[str]) -> bool` - Check if modality lists have common elements
- `new_incompatible_types_error(request_id) -> JSONRPCResponse` - Create content type not supported error response
- `new_not_implemented_error(request_id) -> JSONRPCResponse` - Create unsupported operation error response

**Usage Examples:**
```python
from solace_ai_connector.common.server.utils import are_modalities_compatible, new_not_implemented_error

# Check modality compatibility
server_modes = ["text/plain", "application/json"]
client_modes = ["text/plain"]
if are_modalities_compatible(server_modes, client_modes):
    print("Compatible modalities")

# Return error for unimplemented feature
def some_handler(request):
    return new_not_implemented_error(request.id)
```

# content_hash: eeddd5631483c2e4f109b8b4d2f9ab222c69bcee6b37e72a8ea0eace0b03a946
