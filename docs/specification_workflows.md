# Workflows Technical Specification

This document provides a comprehensive technical specification of Workflows in Solace Agent Mesh. It covers protocol details, data structures, configuration schemas, and integration points. For a high-level architectural overview, see [Workflows Architecture](architecture_workflows.md).

## Table of Contents

1. [Agent Card Extensions](#agent-card-extensions)
2. [WorkflowAgentTool Invocation](#workflowagenttool-invocation)
3. [Workflow Protocol Messages](#workflow-protocol-messages)
4. [Node Type Specifications](#node-type-specifications)
5. [Template Expression System](#template-expression-system)
6. [Workflow Definition Schema](#workflow-definition-schema)
7. [Execution State Management](#execution-state-management)

---

## Agent Card Extensions

Workflows publish Agent Cards with specific extensions that identify them as workflows and provide metadata for invocation.

### Extension URIs

| Extension | URI | Purpose |
|-----------|-----|---------|
| Agent Type | `https://solace.com/a2a/extensions/agent-type` | Identifies the agent as a workflow |
| Schemas | `https://solace.com/a2a/extensions/sam/schemas` | Input/output JSON schemas |
| Visualization | `https://solace.com/a2a/extensions/sam/workflow-visualization` | Mermaid diagram of workflow structure |

### Agent Type Extension

```json
{
  "uri": "https://solace.com/a2a/extensions/agent-type",
  "description": "Specifies the type of agent (e.g., 'workflow').",
  "params": {
    "type": "workflow"
  }
}
```

When an agent discovers another agent with `type: workflow`, it creates a `WorkflowAgentTool` instead of the standard `PeerAgentTool`. This enables schema-aware invocation.

### Schemas Extension

```json
{
  "uri": "https://solace.com/a2a/extensions/sam/schemas",
  "description": "Input and output JSON schemas for the workflow.",
  "params": {
    "input_schema": {
      "type": "object",
      "properties": {
        "order_id": {"type": "string"},
        "amount": {"type": "integer"}
      },
      "required": ["order_id", "amount"]
    },
    "output_schema": {
      "type": "object",
      "properties": {
        "status": {"type": "string"},
        "processed_id": {"type": "string"}
      }
    }
  }
}
```

The schemas extension provides:
- `input_schema`: JSON Schema that workflow input must conform to
- `output_schema`: JSON Schema that workflow output will conform to

These schemas are used by:
1. The `WorkflowAgentTool` to generate function declarations for the LLM
2. The workflow engine to validate input on arrival
3. Downstream consumers to understand the output structure

### Visualization Extension

```json
{
  "uri": "https://solace.com/a2a/extensions/sam/workflow-visualization",
  "description": "Mermaid JS diagram of the workflow logic.",
  "params": {
    "mermaid_source": "graph TD\n    Start([Start])\n    check_risk(\"<b>Agent</b><br/>RiskEvaluator\")\n    ..."
  }
}
```

The workflow engine auto-generates a Mermaid diagram from the workflow definition. This diagram shows:
- Node types with appropriate shapes (diamonds for conditionals, circles for joins, etc.)
- Dependencies between nodes
- Branch labels for conditional paths

---

## WorkflowAgentTool Invocation

The `WorkflowAgentTool` provides a dual-mode interface for invoking workflows.

### Tool Declaration Generation

The tool dynamically generates its function declaration from the workflow's input schema:

```python
# Generated declaration structure
{
  "name": "workflow_MyWorkflow",
  "description": "Invoke the 'MyWorkflow' workflow. Dual-mode: provide parameters directly OR 'input_artifact'.",
  "parameters": {
    "type": "object",
    "properties": {
      "input_artifact": {
        "type": "string",
        "description": "Filename of an existing artifact containing the input JSON data. Use this OR individual parameters.",
        "nullable": true
      },
      "order_id": {
        "type": "string",
        "description": "...",
        "nullable": true
      },
      "amount": {
        "type": "integer",
        "description": "...",
        "nullable": true
      }
    },
    "required": []
  }
}
```

All parameters are marked as optional (`nullable: true`, empty `required` array) to support both invocation modes.

### Parameter Mode

When the LLM provides parameters directly (without `input_artifact`):

1. **Validation**: Parameters are validated against the workflow's `input_schema` using JSON Schema
2. **Artifact Creation**: Valid parameters are serialized to JSON and saved as an artifact named `wi_<workflow_name>.json`
3. **Invocation**: The artifact reference is included in the A2A message

```python
# Example parameter mode call
workflow_MyWorkflow(order_id="ORD-123", amount=500)

# Results in artifact: wi_MyWorkflow.json
# Contents: {"order_id": "ORD-123", "amount": 500}
```

Parameter mode is best for:
- Simple inputs generated by the LLM
- Cases where the LLM is constructing new data

### Artifact Mode

When the LLM provides an `input_artifact` reference:

1. **Pass-through**: The artifact filename is passed directly to the workflow
2. **No Re-validation**: The tool doesn't re-validate (the workflow validates on receipt)
3. **No Re-serialization**: Data stays in artifact form, never re-tokenized

```python
# Example artifact mode call
workflow_MyWorkflow(input_artifact="previous_output.json")
```

Artifact mode is best for:
- Passing large datasets without re-tokenizing
- Chaining workflow outputs to inputs
- Preserving data integrity for critical values

### A2A Message Structure

Both modes result in an A2A `SendMessageRequest` with this structure:

```json
{
  "message": {
    "parts": [
      {
        "text": "Invoking workflow with input artifact: wi_MyWorkflow.json"
      }
    ]
  },
  "metadata": {
    "sessionBehavior": "RUN_BASED",
    "parentTaskId": "<parent_task_id>",
    "function_call_id": "<adk_function_call_id>",
    "agent_name": "MyWorkflow",
    "invoked_with_artifacts": [
      {
        "filename": "wi_MyWorkflow.json",
        "version": 1
      }
    ]
  }
}
```

Key metadata fields:
- `sessionBehavior: "RUN_BASED"`: Each workflow execution runs in isolated context
- `invoked_with_artifacts`: References the input artifact(s)
- `function_call_id`: Links back to the ADK function call for response routing

---

## Workflow Protocol Messages

Workflows communicate using structured `DataPart` messages embedded in A2A protocol messages.

### WorkflowNodeRequestData

Sent by the workflow engine to an agent when invoking it as a node:

```python
class WorkflowNodeRequestData(BaseModel):
    type: Literal["workflow_node_request"] = "workflow_node_request"
    workflow_name: str          # Name of the workflow
    node_id: str                # ID of the workflow node
    input_schema: Optional[Dict[str, Any]]   # Schema override (or None to use agent's default)
    output_schema: Optional[Dict[str, Any]]  # Schema override (or None to use agent's default)
    suggested_output_filename: Optional[str] # Suggested filename for output artifact
```

This data part appears as the first part in the A2A message. The `WorkflowNodeHandler` in the target agent detects this and activates workflow mode.

### WorkflowNodeResultData

Returned by an agent to the workflow engine after node execution:

```python
class WorkflowNodeResultData(BaseModel):
    type: Literal["workflow_node_result"] = "workflow_node_result"
    status: Literal["success", "failure"]
    artifact_name: Optional[str]        # Output artifact filename (if success)
    artifact_version: Optional[int]     # Output artifact version
    error_message: Optional[str]        # Error description (if failure)
    validation_errors: Optional[List[str]]  # Schema validation errors
    retry_count: int = 0                # Number of retries attempted
```

### WorkflowExecutionStartData

Published when a workflow execution begins:

```python
class WorkflowExecutionStartData(BaseModel):
    type: Literal["workflow_execution_start"] = "workflow_execution_start"
    workflow_name: str
    execution_id: str
    input_artifact_ref: Optional[ArtifactRef]
    workflow_input: Optional[Dict[str, Any]]
```

### WorkflowNodeExecutionStartData

Published when a workflow node begins execution:

```python
class WorkflowNodeExecutionStartData(BaseModel):
    type: Literal["workflow_node_execution_start"] = "workflow_node_execution_start"
    node_id: str
    node_type: str  # "agent", "conditional", "switch", "join", "loop", "map", "fork"
    agent_name: Optional[str]
    input_artifact_ref: Optional[ArtifactRef]
    iteration_index: Optional[int]      # For map/loop iterations
    sub_task_id: Optional[str]          # Links to A2A sub-task
    parent_node_id: Optional[str]       # For nested executions

    # Conditional-specific
    condition: Optional[str]
    true_branch: Optional[str]
    false_branch: Optional[str]

    # Switch-specific
    cases: Optional[List[SwitchCaseInfo]]
    default_branch: Optional[str]

    # Join-specific
    wait_for: Optional[List[str]]
    join_strategy: Optional[str]
    join_n: Optional[int]

    # Loop-specific
    max_iterations: Optional[int]
```

### WorkflowNodeExecutionResultData

Published when a workflow node completes:

```python
class WorkflowNodeExecutionResultData(BaseModel):
    type: Literal["workflow_node_execution_result"] = "workflow_node_execution_result"
    node_id: str
    status: Literal["success", "failure", "skipped"]
    output_artifact_ref: Optional[ArtifactRef]
    error_message: Optional[str]
    condition_result: Optional[bool]    # For conditional nodes
    selected_branch: Optional[str]      # Which branch was taken
```

### WorkflowExecutionResultData

Published when a workflow execution completes:

```python
class WorkflowExecutionResultData(BaseModel):
    type: Literal["workflow_execution_result"] = "workflow_execution_result"
    workflow_name: str
    execution_id: str
    status: Literal["success", "failure"]
    output_artifact_ref: Optional[ArtifactRef]
    error_message: Optional[str]
```

---

## Node Type Specifications

### Agent Node

Invokes an agent and waits for its response.

```yaml
- id: string              # Required: Unique node identifier
  type: agent             # Required: Node type
  agent_name: string      # Required: Target agent name (must match agent's agent_name)
  depends_on: [string]    # Optional: Node IDs that must complete first
  input: object           # Optional: Input mapping with template expressions

  # Schema overrides
  input_schema_override: object   # Optional: Override agent's input schema
  output_schema_override: object  # Optional: Override agent's output schema

  # Argo-compatible fields
  when: string            # Optional: Conditional execution expression
  retryStrategy:          # Optional: Retry configuration
    limit: integer
    retryPolicy: "Always" | "OnFailure" | "OnError"
    backoff:
      duration: string    # e.g., "1s", "5m"
      factor: number
      maxDuration: string
  timeout: string         # Optional: Node timeout, e.g., "5m"
```

**Execution**: The workflow engine resolves input templates, constructs a `WorkflowNodeRequestData`, and sends an A2A request to the target agent. Execution is asynchronous; the workflow waits for the agent's response.

### Conditional Node

Binary branching based on an expression.

```yaml
- id: string
  type: conditional
  depends_on: [string]
  condition: string       # Required: Expression to evaluate (simpleeval)
  true_branch: string     # Required: Node ID if condition is true
  false_branch: string    # Optional: Node ID if condition is false
```

**Execution**: The condition is evaluated using `simpleeval` after template resolution. The workflow marks the selected branch as runnable and the other branch as skipped.

**Important**: Branch target nodes must include the conditional node in their `depends_on` list.

### Switch Node

Multi-way branching with first-match semantics.

```yaml
- id: string
  type: switch
  depends_on: [string]
  cases:                  # Required: Ordered list of cases
    - when: string        # Condition expression
      then: string        # Target node ID
  default: string         # Optional: Default node if no case matches
```

**Execution**: Cases are evaluated in order. The first case whose condition evaluates to true wins. If no case matches and `default` is specified, that node runs.

### Map Node

Parallel iteration over an array.

```yaml
- id: string
  type: map
  depends_on: [string]
  items: string | object  # Required: Template expression for array, or coalesce/concat object
  node: string            # Required: Node ID to execute for each item
  concurrency_limit: integer  # Optional: Max concurrent executions
  max_items: integer      # Optional: Safety limit (default: 100)
```

**Argo aliases**: `withParam` (string) and `withItems` (array literal) can be used instead of `items`.

**Item Access**: The target node accesses the current item via `{{_map_item}}` and nested fields via `{{_map_item.field}}`.

**Output Structure**:
```json
{
  "results": [
    {"output": "from item 0"},
    {"output": "from item 1"}
  ]
}
```

### Fork Node

Parallel execution of multiple branches with merged output.

```yaml
- id: string
  type: fork
  depends_on: [string]
  branches:               # Required: Branch definitions
    - id: string          # Branch identifier
      agent_name: string  # Agent to invoke
      input: object       # Input mapping
      output_key: string  # Key for this branch in merged output
  fail_fast: boolean      # Optional: Cancel remaining branches on failure (default: true)
```

**Output Structure**:
```json
{
  "<output_key_1>": { ... branch 1 output ... },
  "<output_key_2>": { ... branch 2 output ... }
}
```

### Join Node

Synchronization point for parallel branches.

```yaml
- id: string
  type: join
  depends_on: [string]
  wait_for: [string]      # Required: Node IDs to wait for
  strategy: "all" | "any" | "n_of_m"  # Optional: Wait strategy (default: "all")
  n: integer              # Required for n_of_m: How many must complete
```

**Strategies**:
- `all`: Wait for all nodes in `wait_for` to complete
- `any`: Complete when the first node finishes; remaining branches may be cancelled
- `n_of_m`: Complete when `n` of the `wait_for` nodes finish

### Loop Node

While-loop iteration until a condition becomes false.

```yaml
- id: string
  type: loop
  depends_on: [string]
  node: string            # Required: Node ID to execute repeatedly
  condition: string       # Required: Continue while this is true
  max_iterations: integer # Optional: Safety limit (default: 100)
  delay: string           # Optional: Delay between iterations, e.g., "5s"
```

**Execution**: The target node is executed, then the condition is re-evaluated. If true, the node runs again. Continues until condition is false or `max_iterations` is reached.

---

## Template Expression System

Template expressions enable data flow between nodes using `{{path.to.value}}` syntax.

### Data Sources

| Source | Syntax | Description |
|--------|--------|-------------|
| Workflow input | `{{workflow.input.field}}` | Access workflow input fields |
| Node output | `{{node_id.output.field}}` | Access completed node's output |
| Map item | `{{_map_item}}` or `{{_map_item.field}}` | Current item in map iteration |

### Operators

#### Coalesce

Returns the first non-null value from a list:

```yaml
output_mapping:
  status:
    coalesce:
      - "{{branch_a.output.status}}"
      - "{{branch_b.output.status}}"
      - "default_value"
```

Essential for conditional workflows where only one branch executes.

#### Concat

Joins strings or arrays:

```yaml
output_mapping:
  summary:
    concat:
      - "Processed order "
      - "{{workflow.input.order_id}}"
      - " with status: "
      - "{{final_node.output.status}}"
```

### Resolution

Template expressions are resolved by the DAGExecutor before node execution:

1. Parse expression to extract path components
2. Navigate to the referenced data in workflow state
3. Return the resolved value (or null if path doesn't exist)

Templates in `input` mappings are resolved when preparing node input. Templates in `output_mapping` are resolved after all nodes complete.

---

## Workflow Definition Schema

Complete workflow definition structure:

```yaml
workflow:
  description: string     # Required: Human-readable description

  input_schema:           # Optional: JSON Schema for workflow input
    type: object
    properties: {}
    required: []

  output_schema:          # Optional: JSON Schema for workflow output
    type: object
    properties: {}
    required: []

  nodes:                  # Required: List of workflow nodes
    - id: string
      type: string
      # ... node-specific fields

  output_mapping:         # Required: Map node outputs to workflow output
    field_name: "{{node_id.output.field}}"

  skills:                 # Optional: Skills for agent card
    - id: string
      name: string
      description: string
      tags: [string]

  # Argo-compatible fields
  onExit: string | object # Optional: Exit handler
  failFast: boolean       # Optional: Stop on failure (default: true)
  retryStrategy: object   # Optional: Default retry strategy
```

### Exit Handler

Simple form (single node):
```yaml
onExit: cleanup_node
```

Conditional form:
```yaml
onExit:
  always: notification_node      # Runs regardless of outcome
  onSuccess: success_handler     # Runs only on success
  onFailure: failure_handler     # Runs only on failure
```

### Validation

The workflow definition is validated at load time:

1. **DAG Structure**: No cycles, all dependencies reference existing nodes
2. **Branch Dependencies**: Conditional/switch branch targets must depend on their parent
3. **Reference Validity**: All node references (exit handlers, join wait_for, etc.) must exist
4. **Schema Validity**: Input/output schemas must be valid JSON Schema

---

## Execution State Management

### WorkflowExecutionContext

Tracks a single workflow execution:

```python
class WorkflowExecutionContext:
    execution_id: str           # Unique execution identifier
    workflow_name: str
    task_id: str                # A2A task ID
    caller_agent: str           # Who invoked the workflow
    input_artifact: ArtifactRef
    start_time: datetime

    # Sub-task tracking
    sub_task_to_node: Dict[str, str]  # Maps sub-task IDs to node IDs
    node_to_sub_task: Dict[str, str]  # Reverse mapping
```

### WorkflowExecutionState

Tracks node execution progress:

```python
class WorkflowExecutionState:
    execution_id: str
    status: Literal["running", "completed", "failed"]

    # Node tracking
    completed_nodes: Dict[str, NodeResult]  # node_id -> result
    pending_nodes: List[str]                # Currently executing
    skipped_nodes: Set[str]                 # Skipped by conditionals

    # Data storage
    node_outputs: Dict[str, Any]            # node_id -> output data
    workflow_input: Dict[str, Any]          # Resolved input data

    # For map/loop tracking
    active_branches: Dict[str, BranchState]
```

### State Persistence

Workflow state is persisted to the Session Service:
- Enables recovery if the workflow executor restarts
- Supports long-running workflows
- Provides audit trail of execution

State is updated after each node completion and persisted as a JSON blob keyed by execution ID.

---

## Implementation Reference

| Component | File | Purpose |
|-----------|------|---------|
| Workflow Executor | `src/solace_agent_mesh/workflow/component.py` | Execution engine |
| DAG Executor | `src/solace_agent_mesh/workflow/dag_executor.py` | Node execution logic |
| Node Definitions | `src/solace_agent_mesh/workflow/app.py` | Pydantic models |
| Agent Caller | `src/solace_agent_mesh/workflow/agent_caller.py` | A2A dispatch |
| Node Handler | `src/solace_agent_mesh/agent/sac/workflow_support/handler.py` | Agent-side support |
| Schema Validator | `src/solace_agent_mesh/agent/sac/workflow_support/validator.py` | JSON Schema validation |
| Workflow Tool | `src/solace_agent_mesh/agent/tools/workflow_tool.py` | Tool for invoking workflows |
| Data Models | `src/solace_agent_mesh/common/data_parts.py` | Protocol message models |
| Protocol Handlers | `src/solace_agent_mesh/workflow/protocol/event_handlers.py` | Message handlers |
| Constants | `src/solace_agent_mesh/common/constants.py` | Extension URIs |
