log:
  stdout_log_level: INFO
  log_file_level: DEBUG
  log_file: advanced_workflow_test.log

!include ../shared_config.yaml

apps:
  # ============================================================================
  # AGENT 1: Data Generator
  # Generates a list of items to process
  # ============================================================================
  - name: data_generator_app
    app_base_path: .
    app_module: solace_agent_mesh.agent.sac.app
    broker:
      <<: *broker_connection

    app_config:
      namespace: ${NAMESPACE}
      agent_name: "DataGenerator"
      model: *planning_model
      
      instruction: |
        You generate test data.
        1. Create a JSON artifact "items.json" with: {"items": [{"id": 1, "name": "Item A"}, {"id": 2, "name": "Item B"}, {"id": 3, "name": "Item C"}]}
        2. End with: «result:artifact=items.json status=success»

      output_schema:
        type: object
        properties:
          items: 
            type: array
            items:
              type: object
              properties:
                id: {type: integer}
                name: {type: string}
        required: [items]

      tools:
        - tool_type: builtin-group
          group_name: "artifact_management"

      session_service:
        <<: *default_session_service
      artifact_service:
        <<: *default_artifact_service
      
      agent_card:
        description: "Generates test data items"
        skills: [{id: "gen_data", name: "Generate Data", description: "Generates data", tags: ["data"]}]
      agent_card_publishing: { interval_seconds: 10 }
      agent_discovery: { enabled: false }

  # ============================================================================
  # AGENT 2: Item Processor
  # Processes a single item
  # ============================================================================
  - name: item_processor_app
    app_base_path: .
    app_module: solace_agent_mesh.agent.sac.app
    broker:
      <<: *broker_connection

    app_config:
      namespace: ${NAMESPACE}
      agent_name: "ItemProcessor"
      model: *planning_model
      
      instruction: |
        You process a single item.
        1. Read 'name' from input.
        2. Create a JSON artifact "result.json" with: {"processed_name": "PROCESSED_" + name, "status": "done"}
        3. End with: «result:artifact=result.json status=success»

      input_schema:
        type: object
        properties:
          id: {type: integer}
          name: {type: string}
        required: [name]

      output_schema:
        type: object
        properties:
          processed_name: {type: string}
          status: {type: string}
        required: [processed_name, status]

      tools:
        - tool_type: builtin-group
          group_name: "artifact_management"

      session_service:
        <<: *default_session_service
      artifact_service:
        <<: *default_artifact_service
      
      agent_card:
        description: "Processes a single item"
        skills: [{id: "process_item", name: "Process Item", description: "Processes item", tags: ["process"]}]
      agent_card_publishing: { interval_seconds: 10 }
      agent_discovery: { enabled: false }

  # ============================================================================
  # AGENT 3: Summarizer
  # Summarizes results
  # ============================================================================
  - name: summarizer_app
    app_base_path: .
    app_module: solace_agent_mesh.agent.sac.app
    broker:
      <<: *broker_connection

    app_config:
      namespace: ${NAMESPACE}
      agent_name: "Summarizer"
      model: *planning_model
      
      instruction: |
        You summarize processing results.
        1. Read 'results' array from input.
        2. Count successful items.
        3. Create a JSON artifact "summary.json" with: {"total_processed": count, "summary_text": "Processed X items successfully."}
        4. End with: «result:artifact=summary.json status=success»

      input_schema:
        type: object
        properties:
          results: 
            type: array
            items:
              type: object
              properties:
                processed_name: {type: string}
                status: {type: string}
        required: [results]

      output_schema:
        type: object
        properties:
          total_processed: {type: integer}
          summary_text: {type: string}
        required: [total_processed, summary_text]

      tools:
        - tool_type: builtin-group
          group_name: "artifact_management"

      session_service:
        <<: *default_session_service
      artifact_service:
        <<: *default_artifact_service
      
      agent_card:
        description: "Summarizes results"
        skills: [{id: "summarize", name: "Summarize", description: "Summarizes results", tags: ["summary"]}]
      agent_card_publishing: { interval_seconds: 10 }
      agent_discovery: { enabled: false }

  # ============================================================================
  # WORKFLOW: AdvancedProcessor
  # ============================================================================
  - name: advanced_processor_workflow
    app_base_path: .
    app_module: solace_agent_mesh.workflow.app
    broker:
      <<: *broker_connection

    app_config:
      namespace: ${NAMESPACE}
      agent_name: "AdvancedProcessor"
      display_name: "Advanced Processing Workflow"

      workflow:
        description: |
          A comprehensive demonstration of advanced workflow capabilities including parallel processing (Map), conditional branching, and complex output aggregation.

          This workflow operates in two modes:
          1. **Generate Mode**: Automatically generates test data items and processes them.
          2. **Direct Mode**: Processes items provided directly in the input.

          **Workflow Steps:**
          1. **Mode Check**: Determines whether to generate data or use provided data.
          2. **Data Acquisition**: Either generates a list of items or passes through the input items.
          3. **Parallel Processing (Map)**: Processes each item in the list concurrently (up to 2 at a time).
          4. **Summarization**: Aggregates the results from all processed items into a final report.

          **Expected Input:**
          - `mode` (string, required): Either "generate" or "direct".
          - `direct_items` (array, optional): A list of items to process (required if mode is "direct"). Each item should be an object with `id` and `name`.

          **Output:**
          - `final_report` (string): A text summary of the processing results.
          - `item_count` (integer): The total number of items successfully processed.

        input_schema:
          type: object
          properties:
            mode: {type: string, enum: ["generate", "direct"]}
            direct_items: 
              type: array
              items: {type: object}
          required: [mode]

        output_schema:
          type: object
          properties:
            final_report: {type: string}
            item_count: {type: integer}
          required: [final_report, item_count]

        nodes:
          # Step 1: Conditional Branch
          - id: mode_check
            type: conditional
            condition: "'{{workflow.input.mode}}' == 'generate'"
            true_branch: generate_data
            false_branch: use_direct_data

          # Step 2a: Generate Data (Agent)
          - id: generate_data
            type: agent
            agent_persona: "DataGenerator"
            # Implicit input: None (uses workflow input, but agent ignores it)

          # Step 2b: Use Direct Data (Pass-through Agent - simulating by calling generator with override)
          # For simplicity in this test, we'll just use the same generator but pretend it's different
          # In a real scenario, this might be a transformer or just direct access
          # Since we don't have a "PassThrough" node, we'll use DataGenerator again but ignore output
          # Actually, let's just use the same agent but map input differently
          - id: use_direct_data
            type: agent
            agent_persona: "DataGenerator" 
            # We are cheating here for the test - normally we'd pass data through.
            # But let's test the 'coalesce' logic on the output.

          # Step 3: Map (Parallel Processing)
          - id: process_items
            type: map
            depends_on: [generate_data]
            # Coalesce the list from either branch
            # Note: MapNode 'items' field supports templates. 
            # We need to ensure 'items' resolves to a list.
            # Since we can't use coalesce inside the 'items' string directly (it's a template string),
            # we rely on the fact that only one branch runs.
            # BUT, if we reference a skipped node, it returns None.
            # We need a way to say "Output of A OR Output of B".
            # The current template syntax doesn't support OR logic inside {{...}}.
            # Workaround: Use a conditional node to route to the Map, and have the Map
            # use a variable that is set by the previous step? No variables.
            #
            # Actually, this highlights a gap! How do we merge data for the next step?
            #
            # Option A: Two Map nodes (one for each branch), then merge results.
            # Option B: A "Merge" or "PassThrough" agent that unifies the data format.
            #
            # Let's use Option A for this test to demonstrate branching fully.
            
            # This path is dead-ended for now in this config structure because we can't dynamic bind 'items'.
            # Let's simplify: The workflow always generates data for this test.
            # We will test Implicit Input and Map.
            
            items:
              coalesce:
                - "{{generate_data.output.items}}"
                - "{{workflow.input.direct_items}}"
            node: process_single_item
            concurrency_limit: 2

          - id: process_single_item
            type: agent
            agent_persona: "ItemProcessor"
            # Implicit Input: The MapNode passes the item as input to the agent.
            # The agent expects {"id":..., "name":...}. The item is exactly that.
            # So we can omit 'input' mapping!
            # The MapNode logic injects _map_item.
            # Wait, PersonaCaller._resolve_node_input logic for implicit input:
            # "If input is not provided... infer it from dependencies."
            # But a MapNode's target node doesn't have 'depends_on' set in the YAML usually?
            # Actually, the MapNode executes it.
            # The MapNode logic creates a temporary node definition.
            # Does it set dependencies? No.
            # But it sets `_map_item` in `node_outputs`.
            #
            # We need to update `PersonaCaller` to handle implicit input from `_map_item` if present!
            # OR we must explicit map it:
            input:
              id: "{{_map_item.id}}"
              name: "{{_map_item.name}}"

          # Step 4: Summarize
          - id: summarize_results
            type: agent
            agent_persona: "Summarizer"
            depends_on: [process_items]
            # Explicit mapping from Map output
            input:
              results: "{{process_items.output.results}}"

        # Output Mapping with Coalesce/Concat
        output_mapping:
          item_count: "{{summarize_results.output.total_processed}}"
          final_report:
            concat:
              - "Workflow Complete. "
              - "{{summarize_results.output.summary_text}}"
              - " (Mode: "
              - "{{workflow.input.mode}}"
              - ")"

      session_service:
        <<: *default_session_service
      artifact_service:
        <<: *default_artifact_service
      
      agent_card_publishing: { interval_seconds: 10 }
      agent_discovery: { enabled: false }
